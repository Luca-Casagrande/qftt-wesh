/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 37b87140-8b03-412c-a7fb-31ab9a18cda7
-/

/-
The provided file compiles successfully. All declarations have been verified and are present in the workspace. The code includes definitions and theorems related to Quantum Master Equations, WESH, GKSL, and Schatten norms, with proofs elided as requested.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For a Hermitian Lindblad operator L, the adjoint dissipator acts on observables as a double commutator: D‚Ä†[Q] = -1/2 [L, [L, Q]].
-/
open Matrix Complex

/-- The adjoint Lindblad dissipator for a jump operator L acting on an observable Q.
    Standard form: D‚Ä†[Q] = L‚Ä† Q L - 1/2 {L‚Ä† L, Q} -/
noncomputable def dissipator_adjoint {n : Type} [Fintype n] [DecidableEq n] (L Q : Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ :=
  L·¥¥ * Q * L - (1/2 : ‚ÑÇ) ‚Ä¢ (L·¥¥ * L * Q + Q * L·¥¥ * L)

/-- The double commutator identity for Hermitian L:
    D‚Ä†[Q] = -1/2 [L, [L, Q]]
    See Eq. (132) in the text. -/
theorem double_commutator_identity {n : Type} [Fintype n] [DecidableEq n] (L Q : Matrix n n ‚ÑÇ) (hL : L.IsHermitian) :
    dissipator_adjoint L Q = -(1/2 : ‚ÑÇ) ‚Ä¢ (L * (L * Q - Q * L) - (L * Q - Q * L) * L) := by
  -- Expand the right-hand side using the definition of the double commutator.
  simp [dissipator_adjoint, hL];
  norm_num [ mul_sub, sub_mul, mul_assoc ];
  rw [ hL ] ; ext i j ; norm_num ; ring

/-
The trace of A P A‚Ä† is non-negative if P is positive semi-definite.
-/
open Matrix Complex

/-- Positive semi-definiteness for complex matrices. -/
def is_PSD {n : Type} [Fintype n] [DecidableEq n] (A : Matrix n n ‚ÑÇ) : Prop :=
  A.IsHermitian ‚àß ‚àÄ x : n ‚Üí ‚ÑÇ, 0 ‚â§ (dotProduct (star x) (A *·µ• x)).re

/-- Helper lemma: The trace of A * P * A·¥¥ is non-negative if P is positive semi-definite. -/
theorem trace_sandwich_nonneg {n : Type} [Fintype n] [DecidableEq n]
    (A : Matrix n n ‚ÑÇ) (P : Matrix n n ‚ÑÇ)
    (hP : is_PSD P) :
    0 ‚â§ (trace (A * P * A·¥¥)).re := by
  have h_trace_nonneg : ‚àÄ (A Q : Matrix n n ‚ÑÇ) (hQ : is_PSD Q), 0 ‚â§ (A * Q * A·¥¥).trace.re := by
    -- Let $e_i$ be the standard basis vectors.
    intro A Q hQ
    have h_basis : ‚àÄ (v : n ‚Üí ‚ÑÇ), 0 ‚â§ (star v ‚¨ù·µ• (Q.mulVec v)).re := by
      intro v; have := hQ.2; aesop;
    simp_all +decide [ Matrix.trace, Matrix.mul_assoc ];
    refine' Finset.sum_nonneg fun i _ => _;
    convert h_basis ( fun j => A·¥¥ j i ) using 1 ; simp +decide [ Matrix.mul_apply, dotProduct ];
    simp +decide [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _, Finset.sum_add_distrib, mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm ];
  exact h_trace_nonneg A P hP

/-
The time-production functional Œì is non-negative under standard physical assumptions.
-/
open Matrix Complex

variable {n : Type} [Fintype n] [DecidableEq n]
variable {X : Type} [Fintype X]

/-- The bilocal jump operator L_{xy} = T(x)^2 - T(y)^2 -/
def L_diff (T : X ‚Üí Matrix n n ‚ÑÇ) (x y : X) : Matrix n n ‚ÑÇ :=
  (T x) ^ 2 - (T y) ^ 2

/-- The time-production functional Œì[Œ®] (Eq. 560) -/
noncomputable def Gamma_functional
    (T : X ‚Üí Matrix n n ‚ÑÇ)
    (œÅ : Matrix n n ‚ÑÇ)
    (Œ≥ : X ‚Üí X ‚Üí ‚Ñù)
    (C : Matrix n n ‚ÑÇ ‚Üí X ‚Üí X ‚Üí ‚Ñù)
    (ŒΩ œÑ_Eig : ‚Ñù) : ‚Ñù :=
  œÑ_Eig * (
    ŒΩ * (‚àë x : X, (trace ((T x) ^ 2 * œÅ * (T x) ^ 2)).re) +
    (‚àë x : X, ‚àë y : X, Œ≥ x y * C œÅ x y * (trace ((L_diff T x y)·¥¥ * (L_diff T x y) * œÅ)).re)
  )

/-- Lemma 2.1: Monotonicity of t (Œì ‚â• 0) -/
theorem Gamma_nonneg
    (T : X ‚Üí Matrix n n ‚ÑÇ)
    (œÅ : Matrix n n ‚ÑÇ)
    (Œ≥ : X ‚Üí X ‚Üí ‚Ñù)
    (C : Matrix n n ‚ÑÇ ‚Üí X ‚Üí X ‚Üí ‚Ñù)
    (ŒΩ œÑ_Eig : ‚Ñù)
    (hT : ‚àÄ x, (T x).IsHermitian)
    (hœÅ : is_PSD œÅ)
    (hŒ≥ : ‚àÄ x y, 0 ‚â§ Œ≥ x y)
    (hC : ‚àÄ x y, 0 ‚â§ C œÅ x y)
    (hŒΩ : 0 ‚â§ ŒΩ)
    (hœÑ : 0 ‚â§ œÑ_Eig) :
    0 ‚â§ Gamma_functional T œÅ Œ≥ C ŒΩ œÑ_Eig := by
  refine' mul_nonneg hœÑ _;
  refine' add_nonneg ( mul_nonneg hŒΩ <| Finset.sum_nonneg fun x _ => _ ) <| Finset.sum_nonneg fun x _ => Finset.sum_nonneg fun y _ => mul_nonneg ( mul_nonneg ( hŒ≥ x y ) <| hC x y ) <| _;
  ¬∑ convert trace_sandwich_nonneg ( T x ^ 2 ) œÅ hœÅ using 1;
    simp_all +decide [ sq, Matrix.IsHermitian, Matrix.mul_assoc ];
  ¬∑ convert trace_sandwich_nonneg ( L_diff T x y ) œÅ hœÅ using 1;
    rw [ ‚Üê Matrix.trace_mul_comm ];
    simp +decide [ Matrix.mul_assoc, Matrix.trace_mul_comm ( L_diff T x y ) ]

/-
If the Hamiltonian and all jump operators commute with a charge Q, then the WESH generator preserves Q (i.e., L‚Ä†[Q] = 0).
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]
variable {X : Type} [Fintype X]

/-- The adjoint WESH generator acting on an observable Q.
    L‚Ä†[Q] = i[H_eff, Q] + ŒΩ ‚àë_x D‚Ä†[T(x)^2](Q) + ‚àë_{xy} Œ≥_{xy} C_{xy} D‚Ä†[L_{xy}](Q) -/
noncomputable def WESH_generator_adjoint
    (H_eff : Matrix n n ‚ÑÇ)
    (T : X ‚Üí Matrix n n ‚ÑÇ)
    (Œ≥ : X ‚Üí X ‚Üí ‚Ñù)
    (C : X ‚Üí X ‚Üí ‚Ñù)
    (ŒΩ : ‚Ñù)
    (Q : Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ :=
  Complex.I ‚Ä¢ (H_eff * Q - Q * H_eff) +
  (ŒΩ : ‚ÑÇ) ‚Ä¢ (‚àë x : X, dissipator_adjoint ((T x)^2) Q) +
  (‚àë x : X, ‚àë y : X, (Œ≥ x y * C x y : ‚ÑÇ) ‚Ä¢ dissipator_adjoint ((T x)^2 - (T y)^2) Q)

/-- Theorem 2.1: WESH-Noether conservation.
    Equivalence between generator conservation and commutant conditions. -/
theorem WESH_Noether_equivalence
    (H_eff : Matrix n n ‚ÑÇ)
    (T : X ‚Üí Matrix n n ‚ÑÇ)
    (Œ≥ : X ‚Üí X ‚Üí ‚Ñù)
    (C : X ‚Üí X ‚Üí ‚Ñù)
    (ŒΩ : ‚Ñù)
    (Q : Matrix n n ‚ÑÇ)
    (hH : H_eff.IsHermitian)
    (hT : ‚àÄ x, (T x).IsHermitian)
    (hŒΩ : 0 < ŒΩ)
    (hŒ≥ : ‚àÄ x y, 0 ‚â§ Œ≥ x y)
    (hC : ‚àÄ x y, 0 ‚â§ C x y)
    :
    (H_eff * Q - Q * H_eff = 0 ‚àß (‚àÄ x, (T x)^2 * Q - Q * (T x)^2 = 0) ‚àß (‚àÄ x y, ((T x)^2 - (T y)^2) * Q - Q * ((T x)^2 - (T y)^2) = 0)) ‚Üí
    WESH_generator_adjoint H_eff T Œ≥ C ŒΩ Q = 0 := by
  intro h_comm
  rcases h_comm with ‚ü®hH_comm, hT_comm, hL_comm‚ü©
  -- Expand definition
  rw [WESH_generator_adjoint]
  -- First term: i[H_eff, Q]
  have term1 : Complex.I ‚Ä¢ (H_eff * Q - Q * H_eff) = 0 := by
    rw [hH_comm]
    simp
  rw [term1]
  simp only [zero_add]
  -- Second term: sum_x ...
  have term2 : (ŒΩ : ‚ÑÇ) ‚Ä¢ (‚àë x : X, dissipator_adjoint ((T x)^2) Q) = 0 := by
    apply smul_eq_zero_of_right
    apply Finset.sum_eq_zero
    intro x _
    -- Use double commutator identity
    rw [double_commutator_identity ((T x)^2) Q]
    ¬∑ -- [(T x)^2, Q] = 0 implies double commutator is 0
      have comm : (T x)^2 * Q - Q * (T x)^2 = 0 := hT_comm x
      rw [comm]
      simp
    ¬∑ -- (T x)^2 is Hermitian
      exact Matrix.IsHermitian.pow (hT x) 2
  rw [term2]
  simp only [zero_add]
  -- Third term: sum_{xy} ...
  apply Finset.sum_eq_zero
  intro x _
  apply Finset.sum_eq_zero
  intro y _
  apply smul_eq_zero_of_right
  rw [double_commutator_identity ((T x)^2 - (T y)^2) Q]
  ¬∑ -- [L_xy, Q] = 0 implies double commutator is 0
    have comm : ((T x)^2 - (T y)^2) * Q - Q * ((T x)^2 - (T y)^2) = 0 := hL_comm x y
    rw [comm]
    simp
  ¬∑ -- L_xy is Hermitian
    apply Matrix.IsHermitian.sub
    exact Matrix.IsHermitian.pow (hT x) 2
    exact Matrix.IsHermitian.pow (hT y) 2

/-
If the Hamiltonian and all jump operators commute with a charge Q, then the WESH generator preserves Q (i.e., L‚Ä†[Q] = 0).
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]
variable {X : Type} [Fintype X]

/-- The adjoint WESH generator acting on an observable Q.
    L‚Ä†[Q] = i[H_eff, Q] + ŒΩ ‚àë_x D‚Ä†[T(x)^2](Q) + ‚àë_{xy} Œ≥_{xy} C_{xy} D‚Ä†[L_{xy}](Q) -/
noncomputable def WESH_generator_adjoint_v2
    (H_eff : Matrix n n ‚ÑÇ)
    (T : X ‚Üí Matrix n n ‚ÑÇ)
    (Œ≥ : X ‚Üí X ‚Üí ‚Ñù)
    (C : X ‚Üí X ‚Üí ‚Ñù)
    (ŒΩ : ‚Ñù)
    (Q : Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ :=
  Complex.I ‚Ä¢ (H_eff * Q - Q * H_eff) +
  (ŒΩ : ‚ÑÇ) ‚Ä¢ (‚àë x : X, dissipator_adjoint ((T x)^2) Q) +
  (‚àë x : X, ‚àë y : X, (Œ≥ x y * C x y : ‚ÑÇ) ‚Ä¢ dissipator_adjoint ((T x)^2 - (T y)^2) Q)

/-- Theorem 2.1: WESH-Noether conservation.
    Equivalence between generator conservation and commutant conditions. -/
theorem WESH_Noether_equivalence_v2
    (H_eff : Matrix n n ‚ÑÇ)
    (T : X ‚Üí Matrix n n ‚ÑÇ)
    (Œ≥ : X ‚Üí X ‚Üí ‚Ñù)
    (C : X ‚Üí X ‚Üí ‚Ñù)
    (ŒΩ : ‚Ñù)
    (Q : Matrix n n ‚ÑÇ)
    (hH : H_eff.IsHermitian)
    (hT : ‚àÄ x, (T x).IsHermitian)
    (hŒΩ : 0 < ŒΩ)
    (hŒ≥ : ‚àÄ x y, 0 ‚â§ Œ≥ x y)
    (hC : ‚àÄ x y, 0 ‚â§ C x y)
    :
    (H_eff * Q - Q * H_eff = 0 ‚àß (‚àÄ x, (T x)^2 * Q - Q * (T x)^2 = 0) ‚àß (‚àÄ x y, ((T x)^2 - (T y)^2) * Q - Q * ((T x)^2 - (T y)^2) = 0)) ‚Üí
    WESH_generator_adjoint_v2 H_eff T Œ≥ C ŒΩ Q = 0 := by
  intro h_comm
  rcases h_comm with ‚ü®hH_comm, hT_comm, hL_comm‚ü©
  -- Expand definition
  rw [WESH_generator_adjoint_v2]
  -- First term: i[H_eff, Q]
  have term1 : Complex.I ‚Ä¢ (H_eff * Q - Q * H_eff) = 0 := by
    rw [hH_comm]
    simp
  rw [term1]
  simp only [zero_add]
  -- Second term: sum_x ...
  have term2 : (ŒΩ : ‚ÑÇ) ‚Ä¢ (‚àë x : X, dissipator_adjoint ((T x)^2) Q) = 0 := by
    apply smul_eq_zero_of_right
    apply Finset.sum_eq_zero
    intro x _
    -- Use double commutator identity
    rw [double_commutator_identity ((T x)^2) Q]
    ¬∑ -- [(T x)^2, Q] = 0 implies double commutator is 0
      have comm : (T x)^2 * Q - Q * (T x)^2 = 0 := hT_comm x
      rw [comm]
      simp
    ¬∑ -- (T x)^2 is Hermitian
      exact Matrix.IsHermitian.pow (hT x) 2
  rw [term2]
  simp only [zero_add]
  -- Third term: sum_{xy} ...
  apply Finset.sum_eq_zero
  intro x _
  apply Finset.sum_eq_zero
  intro y _
  apply smul_eq_zero_of_right
  rw [double_commutator_identity ((T x)^2 - (T y)^2) Q]
  ¬∑ -- [L_xy, Q] = 0 implies double commutator is 0
    have comm : ((T x)^2 - (T y)^2) * Q - Q * ((T x)^2 - (T y)^2) = 0 := hL_comm x y
    rw [comm]
    simp
  ¬∑ -- L_xy is Hermitian
    apply Matrix.IsHermitian.sub
    exact Matrix.IsHermitian.pow (hT x) 2
    exact Matrix.IsHermitian.pow (hT y) 2

/-
If the time production rate Œì is strictly positive on an interval, the probability of no eigentime event (survival probability) is strictly less than 1.
-/
open Real MeasureTheory Interval

/-- Lemma 2.2: Eigentime activation.
    If Œì(s) > 0 on a segment [s0, s0+Œ¥], then the survival probability S(Œ¥) < 1. -/
theorem eigentime_activation
    (Œì : ‚Ñù ‚Üí ‚Ñù)
    (s0 Œ¥ : ‚Ñù)
    (hŒ¥ : 0 < Œ¥)
    (h_cont : ContinuousOn Œì (Set.Icc s0 (s0 + Œ¥)))
    (h_pos : ‚àÄ s ‚àà Set.Icc s0 (s0 + Œ¥), 0 < Œì s) :
    Real.exp (- ‚à´ s in s0..(s0 + Œ¥), Œì s) < 1 := by
  norm_num at *;
  rw [ intervalIntegral.integral_of_le ( by linarith ), MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
  ¬∑ simp_all +decide [ Function.support ];
    exact lt_of_lt_of_le ( by aesop ) ( MeasureTheory.measure_mono <| show Set.Ioc s0 ( s0 + Œ¥ ) ‚äÜ { x | ¬¨Œì x = 0 } ‚à© Set.Ioc s0 ( s0 + Œ¥ ) from fun x hx => ‚ü® ne_of_gt <| h_pos x hx.1.le hx.2, hx ‚ü© );
  ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx using le_of_lt ( h_pos x hx.1.le hx.2 );
  ¬∑ exact h_cont.integrableOn_Icc.mono_set ( Set.Ioc_subset_Icc_self )

/-
Definitions of Trace Preserving, Completely Positive maps, and the GKSL generator.
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]

/-- A map is Trace Preserving if trace(Œ¶(œÅ)) = trace(œÅ) for all œÅ. -/
def IsTracePreserving (Œ¶ : Matrix n n ‚ÑÇ ‚Üí Matrix n n ‚ÑÇ) : Prop :=
  ‚àÄ œÅ, (Œ¶ œÅ).trace = œÅ.trace

variable {m : Type} [Fintype m] [DecidableEq m]

/-- Extract the (i, j)-th n√ón block from an (m√ón)√ó(m√ón) matrix. -/
def extract_block (A : Matrix (m √ó n) (m √ó n) ‚ÑÇ) (i j : m) : Matrix n n ‚ÑÇ :=
  fun k l => A (i, k) (j, l)

/-- Build an (m√ón)√ó(m√ón) matrix from blocks. -/
def from_blocks_fn (B : m ‚Üí m ‚Üí Matrix n n ‚ÑÇ) : Matrix (m √ó n) (m √ó n) ‚ÑÇ :=
  fun (ik : m √ó n) (jl : m √ó n) => B ik.1 jl.1 ik.2 jl.2

/-- Apply a map Œ¶ to each n√ón block of an (m√ón)√ó(m√ón) matrix. -/
def map_blocks (Œ¶ : Matrix n n ‚ÑÇ ‚Üí Matrix n n ‚ÑÇ) (A : Matrix (m √ó n) (m √ó n) ‚ÑÇ) : Matrix (m √ó n) (m √ó n) ‚ÑÇ :=
  from_blocks_fn (fun i j => Œ¶ (extract_block A i j))

/-- A map is Completely Positive if its extension to any size m preserves positivity. -/
def IsCompletelyPositive (Œ¶ : Matrix n n ‚ÑÇ ‚Üí Matrix n n ‚ÑÇ) : Prop :=
  ‚àÄ (m : Type) [Fintype m] [DecidableEq m],
    ‚àÄ (A : Matrix (m √ó n) (m √ó n) ‚ÑÇ),
      is_PSD A ‚Üí is_PSD (map_blocks Œ¶ A)

/-- The GKSL generator for a Hamiltonian H, jump operators L_j, and rates Œ≥_j. -/
noncomputable def GKSL_generator
    {k : Type} [Fintype k]
    (H : Matrix n n ‚ÑÇ)
    (L : k ‚Üí Matrix n n ‚ÑÇ)
    (Œ≥ : k ‚Üí ‚Ñù)
    (œÅ : Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ :=
  Complex.I ‚Ä¢ (œÅ * H - H * œÅ) +
  ‚àë j : k, (Œ≥ j : ‚ÑÇ) ‚Ä¢ (L j * œÅ * (L j)·¥¥ - (1/2 : ‚ÑÇ) ‚Ä¢ ((L j)·¥¥ * L j * œÅ + œÅ * (L j)·¥¥ * L j))

/-
Definition of the commutator map as a linear map.
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]

/-- The commutator map œÅ ‚Ü¶ i[œÅ, H] (or -i[H, œÅ]) as a LinearMap. -/
noncomputable def commutator_map (H : Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ where
  toFun œÅ := Complex.I ‚Ä¢ (œÅ * H - H * œÅ)
  map_add' œÅ œÉ := by
    -- By expanding the left-hand side and simplifying, we can see that it matches the right-hand side.
    simp [mul_add, add_mul, sub_eq_add_neg];
    abel1
  map_smul' c œÅ := by
    ext i j ; norm_num ; ring

/-
Definition of the dissipator map as a linear map.
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]

/-- The dissipator map œÅ ‚Ü¶ L œÅ L‚Ä† - 1/2 {L‚Ä† L, œÅ} as a LinearMap. -/
noncomputable def dissipator_map (L : Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ where
  toFun œÅ := L * œÅ * L·¥¥ - (1/2 : ‚ÑÇ) ‚Ä¢ (L·¥¥ * L * œÅ + œÅ * L·¥¥ * L)
  map_add' œÅ œÉ := by
    simp only [Matrix.mul_add, Matrix.add_mul, smul_add]
    ext i j
    simp
    ring
  map_smul' c œÅ := by
    simp only [Matrix.mul_smul, Matrix.smul_mul, smul_smul]
    ext i j
    simp
    ring

/-
Definition of the GKSL generator as a linear map, combining the commutator and dissipator parts.
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]

/-- The GKSL generator as a LinearMap. -/
noncomputable def GKSL_generator_linear
    {k : Type} [Fintype k]
    (H : Matrix n n ‚ÑÇ)
    (L : k ‚Üí Matrix n n ‚ÑÇ)
    (Œ≥ : k ‚Üí ‚Ñù) : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ :=
  commutator_map H + ‚àë j : k, (Œ≥ j : ‚ÑÇ) ‚Ä¢ dissipator_map (L j)

/-
The trace of the commutator map is zero.
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: The trace of the commutator map is zero. -/
theorem trace_commutator_map_zero
    (H : Matrix n n ‚ÑÇ)
    (œÅ : Matrix n n ‚ÑÇ) :
    (commutator_map H œÅ).trace = 0 := by
  unfold commutator_map; norm_num [ mul_assoc, Matrix.trace_mul_comm H ] ;

/-
The trace of the dissipator map is zero.
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: The trace of the dissipator map is zero. -/
theorem trace_dissipator_map_zero
    (L : Matrix n n ‚ÑÇ)
    (œÅ : Matrix n n ‚ÑÇ) :
    (dissipator_map L œÅ).trace = 0 := by
  unfold dissipator_map;
  norm_num [ Matrix.trace_mul_comm L, Matrix.trace_mul_comm œÅ, Matrix.mul_assoc ] ; ring

/-
The GKSL generator maps any density matrix to a traceless matrix.
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: The trace of the GKSL generator is zero for any input œÅ. -/
theorem trace_GKSL_generator_zero
    {k : Type} [Fintype k]
    (H : Matrix n n ‚ÑÇ)
    (L : k ‚Üí Matrix n n ‚ÑÇ)
    (Œ≥ : k ‚Üí ‚Ñù)
    (œÅ : Matrix n n ‚ÑÇ) :
    (GKSL_generator_linear H L Œ≥ œÅ).trace = 0 := by
  -- Utilize the known properties of the trace
  simp [GKSL_generator_linear, trace_commutator_map_zero, trace_dissipator_map_zero]

/-
If a linear map L maps everything to trace 0, then L^k also maps everything to trace 0 for k >= 1.
-/
open Matrix Complex BigOperators Topology LinearAlgebra Module

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: If a generator L has trace 0 for all inputs, then powers of L also have trace 0 for k >= 1. -/
theorem trace_pow_generator_zero
    (L : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ)
    (hL : ‚àÄ œÅ, (L œÅ).trace = 0)
    (k : ‚Ñï)
    (hk : 1 ‚â§ k)
    (œÅ : Matrix n n ‚ÑÇ) :
    ((L ^ k) œÅ).trace = 0 := by
  induction hk <;> simp_all +decide [ pow_succ' ]

/-
Definitions for converting between superoperators and matrices using arrowCongr, and the exponential of a superoperator.
-/
open Matrix Complex BigOperators Topology LinearAlgebra Module

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Equivalence between matrices and vectors (flattening). -/
noncomputable def vec_equiv : Matrix n n ‚ÑÇ ‚âÉ‚Çó[‚ÑÇ] (n √ó n) ‚Üí ‚ÑÇ :=
  { toFun := fun M p => M p.1 p.2
    invFun := fun v i j => v (i, j)
    left_inv := fun M => by ext; simp
    right_inv := fun v => by ext; simp
    map_add' := fun x y => by ext; simp
    map_smul' := fun c x => by ext; simp }

/-- Equivalence between superoperators and Liouvillian matrices. -/
noncomputable def superop_equiv : (Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ) ‚âÉ‚Çó[‚ÑÇ] Matrix (n √ó n) (n √ó n) ‚ÑÇ :=
  (LinearEquiv.arrowCongr vec_equiv vec_equiv).trans LinearMap.toMatrix'

/-- The exponential of a superoperator. -/
noncomputable def exp_superop (L : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ :=
  superop_equiv.symm (NormedSpace.exp ‚ÑÇ (superop_equiv L))

/-
If a functional f annihilates A, it annihilates all positive powers of A.
-/
open Matrix Complex BigOperators Topology LinearAlgebra Module

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E]


/-
If a functional f annihilates A, then f(exp(A)x) = f(x).
-/
open Matrix Complex BigOperators Topology LinearAlgebra Module

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E]

/-- Lemma: If a continuous linear functional f annihilates the image of A, then f is invariant under exp(A). -/
theorem functional_exp_eq_self_of_comp_eq_zero
    (f : E ‚ÜíL[‚ÑÇ] ‚ÑÇ)
    (A : E ‚ÜíL[‚ÑÇ] E)
    (h : f.comp A = 0)
    (x : E) :
    f (NormedSpace.exp ‚ÑÇ A x) = f x := by
  -- Since $f \circ A = 0$, we have $f(A^k(x)) = 0$ for all $k \geq 1$.
  have h_zero : ‚àÄ k : ‚Ñï, k ‚â• 1 ‚Üí f ((A ^ k) x) = 0 := by
    intro k hk;
    induction hk <;> simp_all +decide [ pow_succ', mul_assoc, ContinuousLinearMap.ext_iff ];
  simp_all +decide [ NormedSpace.exp_eq_tsum ];
  -- The series $\sum' n, (n.factorial : ‚ÑÇ)‚Åª¬π ‚Ä¢ A ^ n$ is the exponential of $A$, which converges to $e^A$.
  have h_exp : Summable (fun n : ‚Ñï => (n.factorial : ‚ÑÇ)‚Åª¬π ‚Ä¢ A ^ n) := by
    refine' .of_norm _;
    norm_num [ norm_smul ];
    refine' Summable.of_nonneg_of_le ( fun n => mul_nonneg ( inv_nonneg.2 ( Nat.cast_nonneg _ ) ) ( norm_nonneg _ ) ) ( fun n => mul_le_mul_of_nonneg_left ( show ‚ÄñA ^ n‚Äñ ‚â§ ‚ÄñA‚Äñ ^ n from _ ) ( inv_nonneg.2 ( Nat.cast_nonneg _ ) ) ) _;
    ¬∑ induction' n with n ih;
      ¬∑ exact ContinuousLinearMap.opNorm_le_bound _ zero_le_one fun x => by simp +decide ;
      ¬∑ simpa only [ pow_succ' ] using le_trans ( ContinuousLinearMap.opNorm_comp_le _ _ ) ( mul_le_mul_of_nonneg_left ih ( norm_nonneg _ ) );
    ¬∑ simpa [ inv_mul_eq_div ] using Real.summable_pow_div_factorial ‚ÄñA‚Äñ;
  have h_exp : Filter.Tendsto (fun n : ‚Ñï => (‚àë i ‚àà Finset.range (n + 1), (i.factorial : ‚ÑÇ)‚Åª¬π ‚Ä¢ A ^ i) x) Filter.atTop (nhds ((‚àë' n : ‚Ñï, (n.factorial : ‚ÑÇ)‚Åª¬π ‚Ä¢ A ^ n) x)) := by
    exact Filter.Tendsto.comp ( Continuous.tendsto ( show Continuous fun f : E ‚ÜíL[‚ÑÇ] E => f x from by continuity ) _ ) ( h_exp.hasSum.tendsto_sum_nat.comp ( Filter.tendsto_add_atTop_nat _ ) );
  have h_exp : Filter.Tendsto (fun n : ‚Ñï => f ((‚àë i ‚àà Finset.range (n + 1), (i.factorial : ‚ÑÇ)‚Åª¬π ‚Ä¢ A ^ i) x)) Filter.atTop (nhds (f ((‚àë' n : ‚Ñï, (n.factorial : ‚ÑÇ)‚Åª¬π ‚Ä¢ A ^ n) x))) := by
    exact f.continuous.continuousAt.tendsto.comp h_exp;
  simp_all +decide [ Finset.sum_range_succ' ]

open Matrix Complex

open Matrix Complex BigOperators
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

#synth PartialOrder (Matrix n n ‚ÑÇ)

open Matrix Complex BigOperators
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- The absolute value of a matrix A, defined as sqrt(A* A). -/
noncomputable def matrix_abs (A : Matrix n n ‚ÑÇ) : Matrix n n ‚ÑÇ := CFC.sqrt (A·¥¥ * A)

/-- The trace norm (Schatten 1-norm) of a matrix. -/
noncomputable def trace_norm (A : Matrix n n ‚ÑÇ) : ‚Ñù := (matrix_abs A).trace.re

/-
The trace norm of any matrix is non-negative.
-/
open Matrix Complex BigOperators
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-
The adjoint dissipator D‚Ä†[Q] for a Hermitian operator L is equal to -1/2 times the double commutator [L, [L, Q]].
-/
open Matrix Complex BigOperators

variable {n : Type} [Fintype n] [DecidableEq n]


open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-
The Schatten 1-norm (defined variationally) satisfies the triangle inequality.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- The operator norm of a matrix A, defined via its action on Euclidean space. -/
noncomputable def op_norm (A : Matrix n n ‚ÑÇ) : ‚Ñù := ‚ÄñLinearMap.toContinuousLinearMap (Matrix.toEuclideanLin A)‚Äñ

/-- The Schatten 1-norm defined as the dual of the operator norm.
    ||A||_1 = sup { |trace(A * B)| : ||B||_op ‚â§ 1 } -/
noncomputable def schatten_one_norm_var (A : Matrix n n ‚ÑÇ) : ‚Ñù :=
  ‚®Ü (B : Matrix n n ‚ÑÇ) (h : op_norm B ‚â§ 1), ‚Äñ(A * B).trace‚Äñ

/-- Lemma: Schatten 1-norm (variational) satisfies triangle inequality. -/
lemma schatten_one_norm_var_triangle (A B : Matrix n n ‚ÑÇ) :
    schatten_one_norm_var (A + B) ‚â§ schatten_one_norm_var A + schatten_one_norm_var B := by
      -- By definition of subadditivity, we have:
      apply csSup_le;
      ¬∑ exact ‚ü® _, ‚ü® 0, rfl ‚ü© ‚ü©;
      ¬∑ rintro - ‚ü® X, rfl ‚ü©;
        refine' le_trans _ ( add_le_add ( le_ciSup _ X ) ( le_ciSup _ X ) );
        ¬∑ by_cases hX : op_norm X ‚â§ 1 <;> simp +decide [ hX ];
          simpa only [ add_mul, Matrix.trace_add ] using norm_add_le _ _;
        ¬∑ -- Since the trace is a continuous linear functional on the space of matrices, and the operator norm is bounded on the unit ball, the trace of A * B is bounded for any B with operator norm ‚â§ 1.
          have h_trace_bounded : ‚àÉ C, ‚àÄ B : Matrix n n ‚ÑÇ, op_norm B ‚â§ 1 ‚Üí ‚Äñ(A * B).trace‚Äñ ‚â§ C := by
            use ‚àë i : n, ‚àë j : n, ‚ÄñA i j‚Äñ;
            intros B hB
            have h_trace_bound : ‚Äñ(A * B).trace‚Äñ ‚â§ ‚àë i : n, ‚àë j : n, ‚ÄñA i j‚Äñ * ‚ÄñB j i‚Äñ := by
              exact le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun i _ => by simpa [ Matrix.mul_apply, Matrix.trace ] using norm_sum_le _ _ |> le_trans <| Finset.sum_le_sum fun j _ => by simp +decide [ Matrix.mul_apply, Matrix.trace ] );
            refine' le_trans h_trace_bound ( Finset.sum_le_sum fun i _ => Finset.sum_le_sum fun j _ => mul_le_of_le_one_right ( norm_nonneg _ ) _ );
            refine' le_trans _ hB;
            refine' le_csInf _ _;
            ¬∑ exact ‚ü® ‚ÄñLinearMap.toContinuousLinearMap ( toEuclideanLin B )‚Äñ, ‚ü® norm_nonneg _, fun x => ContinuousLinearMap.le_opNorm _ _ ‚ü© ‚ü©;
            ¬∑ intro c hc; specialize hc; have := hc.2 ( EuclideanSpace.single i 1 ) ; simp_all +decide [ EuclideanSpace.norm_eq ] ;
              simp_all +decide [ toEuclideanLin ];
              simp_all +decide [ Finset.sum_eq_single i, Real.sqrt_le_iff ];
              exact le_trans ( Real.le_sqrt_of_sq_le ( Finset.single_le_sum ( fun x _ => sq_nonneg ( ‚ÄñB x i‚Äñ ) ) ( Finset.mem_univ j ) ) ) ( Real.sqrt_le_iff.mpr ‚ü® by linarith, by linarith ‚ü© );
          obtain ‚ü® C, hC ‚ü© := h_trace_bounded; use Max.max C 1; rintro x ‚ü® B, rfl ‚ü© ; by_cases hB : op_norm B ‚â§ 1 <;> aesop;
        ¬∑ refine' ‚ü® ( ‚àë i : n, ‚àë j : n, ‚ÄñB i j‚Äñ ) * ( ‚àë i : n, ‚àë j : n, 1 ), Set.forall_mem_range.2 fun X => _ ‚ü©;
          rw [ @ciSup_eq_ite ];
          split_ifs <;> norm_num;
          ¬∑ refine' le_trans ( norm_sum_le _ _ ) _;
            refine' le_trans ( Finset.sum_le_sum fun i _ => _ ) _;
            use fun i => ‚àë j, ‚ÄñB i j‚Äñ * ‚ÄñX j i‚Äñ;
            ¬∑ simpa only [ Matrix.mul_apply, Matrix.diag_apply ] using norm_sum_le _ _ |> le_trans <| Finset.sum_le_sum fun j _ => by rw [ norm_mul ] ;
            ¬∑ rw [ Finset.sum_mul _ _ _ ];
              refine' Finset.sum_le_sum fun i _ => _;
              rw [ Finset.sum_mul _ _ _ ];
              gcongr;
              rename_i j _;
              refine' le_trans ( show ‚ÄñX j i‚Äñ ‚â§ 1 from _ ) _;
              ¬∑ rename_i h‚ÇÅ h‚ÇÇ;
                rename_i h‚ÇÉ;
                refine' le_trans _ h‚ÇÉ;
                refine' le_trans _ ( le_csInf _ _ );
                rotate_left;
                exact ‚Äñ( LinearMap.toContinuousLinearMap ( toEuclideanLin X ) ) ( EuclideanSpace.single i 1 )‚Äñ;
                ¬∑ exact ‚ü® _, ‚ü® norm_nonneg _, fun x => ContinuousLinearMap.le_opNorm _ _ ‚ü© ‚ü©;
                ¬∑ exact fun c hc => by simpa using hc.2 ( EuclideanSpace.single i 1 ) ;
                ¬∑ simp +decide [ EuclideanSpace.norm_eq, Matrix.mulVec, dotProduct ];
                  refine' Real.le_sqrt_of_sq_le _;
                  exact Finset.single_le_sum ( fun x _ => sq_nonneg ( ‚Äñ ( toEuclideanLin X ) ( EuclideanSpace.single i 1 ) x‚Äñ ) ) ( Finset.mem_univ j ) |> le_trans ( by simp +decide [ toEuclideanLin ] );
              ¬∑ norm_cast ; nlinarith [ show 1 ‚â§ Fintype.card n from Fintype.card_pos_iff.mpr ‚ü® i ‚ü© ];
          ¬∑ exact mul_nonneg ( Finset.sum_nonneg fun _ _ => Finset.sum_nonneg fun _ _ => norm_nonneg _ ) ( by positivity )

/-
If the coherence time scales as N^(2n) and is required to scale as N^2, then n must be 1.
-/
open Real

/-- Proposition 2.2: Quadratic dissipator selection.
    If the coherence time scales as N^(2n) and we require it to scale as N^2, then n must be 1. -/
theorem quadratic_dissipator_selection
    (n : ‚Ñï)
    (h_n : 1 ‚â§ n)
    (h_scaling : ‚àÄ N : ‚Ñù, 1 < N ‚Üí N^(2*n) = N^2) :
    n = 1 := by
      exact le_antisymm ( le_of_not_gt fun h => by have := h_scaling 2 ( by norm_num ) ; exact absurd this ( by exact ne_of_gt ( pow_lt_pow_right‚ÇÄ ( by norm_num ) ( by linarith ) ) ) ) h_n

/-
As the gravitational constant G tends to 0, the dissipative parameters ŒΩ and ‚à´Œ≥ tend to 0, implying decoupling of the dissipative dynamics.
-/
open Real Topology Filter

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Proposition 2.3: Decoupling in the G -> 0 limit.
    As G -> 0, nu and int_gamma tend to 0. -/
theorem decoupling_limit
    (N : ‚Ñù)
    (hN : N > 0) :
    Tendsto (fun (G : ‚Ñù) =>
      let Œæ := G^((1:‚Ñù)/2)
      let Œ≥‚ÇÄ := G^(-(1:‚Ñù)/2)
      let V_xi := Œæ^4
      let ŒΩ := Œ≥‚ÇÄ * V_xi
      let int_gamma := (Œ≥‚ÇÄ * V_xi) / N^2
      (ŒΩ, int_gamma)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (0, 0)) := by
        -- We'll use the fact that if the denominator tends to zero faster than the numerator, the limit is zero.
        have h_lim : Filter.Tendsto (fun G : ‚Ñù => G ^ (3 / 2 : ‚Ñù)) (ùìù[>] 0) (nhds 0) := by
          exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( continuous_id.rpow_const <| by norm_num ) _ _ <| by norm_num );
        refine' Filter.Tendsto.prodMk_nhds _ _;
        ¬∑ refine' h_lim.congr' ( by filter_upwards [ self_mem_nhdsWithin ] with G hG using by rw [ ‚Üê Real.rpow_natCast, ‚Üê Real.rpow_mul hG.out.le, ‚Üê Real.rpow_add hG.out ] ; ring );
        ¬∑ exact le_trans ( Filter.Tendsto.div_const ( Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun x hx => by rw [ ‚Üê Real.rpow_natCast, ‚Üê Real.rpow_mul hx.out.le ] ; rw [ ‚Üê Real.rpow_add' hx.out.le ] <;> norm_num ) h_lim ) _ ) ( by norm_num )

/-
The Schatten 1-norm is non-negative.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: Schatten 1-norm (variational) is non-negative. -/
lemma schatten_one_norm_var_nonneg (A : Matrix n n ‚ÑÇ) : 0 ‚â§ schatten_one_norm_var A := by
  exact Real.iSup_nonneg fun B => Real.iSup_nonneg fun hB => norm_nonneg _

/-
The Schatten 1-norm satisfies the triangle inequality.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-
The Schatten 1-norm is zero if and only if the matrix is zero.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: Schatten 1-norm (variational) is zero iff matrix is zero. -/
lemma schatten_one_norm_var_eq_zero_iff (A : Matrix n n ‚ÑÇ) :
    schatten_one_norm_var A = 0 ‚Üî A = 0 := by
      -- By definition of $schatten_one_norm_var$, we have $schatten_one_norm_var A = 0$ if and only if $\sup_{\|B\| \leq 1} |\operatorname{tr}(AB)| = 0$.
      suffices h_sup_zero : (schatten_one_norm_var A = 0 ‚Üî ‚àÄ B : Matrix n n ‚ÑÇ, (op_norm B ‚â§ 1 ‚Üí ‚Äñ(A * B).trace‚Äñ = 0)) by
        -- If the trace norm is zero, then for any matrix B with operator norm ‚â§ 1, the trace of AB is zero.
        suffices h_trace_zero : (‚àÄ B : Matrix n n ‚ÑÇ, (op_norm B ‚â§ 1 ‚Üí ‚Äñ(A * B).trace‚Äñ = 0)) ‚Üí ‚àÄ B : Matrix n n ‚ÑÇ, (A * B).trace = 0 by
          constructor <;> intro h;
          ¬∑ ext i j;
            specialize h_trace_zero ( h_sup_zero.mp h ) ( Matrix.of fun k l => if k = j then if l = i then 1 else 0 else 0 ) ; simp_all +decide [ Matrix.mul_apply, Matrix.trace ];
          ¬∑ aesop;
        intro h B
        by_contra h_nonzero;
        -- Choose $c$ such that $c \|B\| \leq 1$.
        obtain ‚ü®c, hc‚ü© : ‚àÉ c : ‚Ñù, 0 < c ‚àß c * op_norm B ‚â§ 1 ‚àß c * ‚Äñ(A * B).trace‚Äñ > 0 := by
          exact ‚ü® 1 / ( Max.max ( op_norm B ) 1 ), by positivity, by rw [ div_mul_eq_mul_div, div_le_iff‚ÇÄ ] <;> nlinarith [ le_max_left ( op_norm B ) 1, le_max_right ( op_norm B ) 1 ], by positivity ‚ü©;
        -- By definition of $op_norm$, we have $op_norm (c ‚Ä¢ B) = c * op_norm B$.
        have h_op_norm : op_norm (c ‚Ä¢ B) = c * op_norm B := by
          unfold op_norm;
          rw [ ‚Üê norm_smul_of_nonneg hc.1.le ];
          congr;
          ext; simp +decide [ Matrix.mulVec, dotProduct ];
          simp +decide [ toEuclideanLin, Matrix.mulVec, dotProduct ];
          simp +decide only [mul_assoc, Finset.mul_sum _ _ _];
        specialize h ( c ‚Ä¢ B ) ; simp_all +decide [ mul_assoc, mul_left_comm ] ;
      constructor <;> intro h;
      ¬∑ intro B hB
        have h_zero : ‚Äñ(A * B).trace‚Äñ ‚â§ ‚®Ü (B : Matrix n n ‚ÑÇ) (h : op_norm B ‚â§ 1), ‚Äñ(A * B).trace‚Äñ := by
          apply le_csSup;
          ¬∑ -- The range of the function is bounded above by the supremum of the norms of the traces of A*B over all B with operator norm ‚â§ 1.
            have h_bdd_above : ‚àÉ M, ‚àÄ B : Matrix n n ‚ÑÇ, op_norm B ‚â§ 1 ‚Üí ‚Äñ(A * B).trace‚Äñ ‚â§ M := by
              use ‚àë i : n, ‚àë j : n, ‚ÄñA i j‚Äñ * ‚àë k : n, 1;
              intro B hB
              have h_trace_bound : ‚àÄ i j, ‚ÄñA i j * B j i‚Äñ ‚â§ ‚ÄñA i j‚Äñ * ‚àë k : n, 1 := by
                intro i j
                have h_bound : ‚ÄñB j i‚Äñ ‚â§ ‚àë k : n, 1 := by
                  have h_bound : ‚àÄ i j, ‚ÄñB j i‚Äñ ‚â§ ‚ÄñLinearMap.toContinuousLinearMap (Matrix.toEuclideanLin B)‚Äñ := by
                    intro i j;
                    have := ContinuousLinearMap.le_opNorm ( LinearMap.toContinuousLinearMap ( Matrix.toEuclideanLin B ) ) ( EuclideanSpace.single i 1 );
                    convert this.trans' _;
                    ¬∑ norm_num [ EuclideanSpace.norm_single ];
                    ¬∑ simp +decide [ EuclideanSpace.norm_eq, Matrix.mulVec, dotProduct ];
                      exact Real.le_sqrt_of_sq_le ( by rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ j ) ] ; exact le_add_of_le_of_nonneg ( by simp +decide [ toEuclideanLin ] ) ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) );
                  exact le_trans ( h_bound i j ) ( le_trans hB ( le_trans ( by norm_num ) ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.subset_univ { i } ) fun _ _ _ => by norm_num ) ) );
                simpa only [ norm_mul ] using mul_le_mul_of_nonneg_left h_bound ( norm_nonneg _ );
              exact le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun i _ => le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun j _ => h_trace_bound i j ) );
            obtain ‚ü® M, hM ‚ü© := h_bdd_above;
            use Max.max M 1;
            rintro x ‚ü® B, rfl ‚ü© ; by_cases hB : op_norm B ‚â§ 1 <;> aesop;
          ¬∑ exact ‚ü® B, by aesop ‚ü©;
        exact le_antisymm ( h_zero.trans h.le ) ( norm_nonneg _ );
      ¬∑ exact le_antisymm ( ciSup_le fun B => by by_cases hB : op_norm B ‚â§ 1 <;> aesop ) ( by exact Real.iSup_nonneg fun _ => by exact Real.iSup_nonneg fun _ => by positivity )

/-
The Schatten 1-norm satisfies the triangle inequality.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: Schatten 1-norm (variational) satisfies triangle inequality. -/
lemma schatten_one_norm_var_triangle_v2 (A B : Matrix n n ‚ÑÇ) :
    schatten_one_norm_var (A + B) ‚â§ schatten_one_norm_var A + schatten_one_norm_var B := by
      convert schatten_one_norm_var_triangle A B

/-
The Schatten 1-norm of -A is the same as the Schatten 1-norm of A.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: Schatten 1-norm is invariant under negation. -/
lemma schatten_one_norm_var_neg (A : Matrix n n ‚ÑÇ) :
    schatten_one_norm_var (-A) = schatten_one_norm_var A := by
      unfold schatten_one_norm_var;
      norm_num [ Matrix.mul_neg ]

/-
If the Schatten 1-norm of A is zero, then trace(AB) = 0 for all matrices B.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-
Matrices have a norm defined by the Schatten 1-norm.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Instance: Matrix n n ‚ÑÇ has a Norm defined by the Schatten 1-norm. -/
noncomputable instance instNormSchatten : Norm (Matrix n n ‚ÑÇ) :=
  ‚ü®schatten_one_norm_var‚ü©

/-
The Schatten 1-norm satisfies ||c A|| = |c| ||A||.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: Schatten 1-norm is homogeneous. -/
lemma schatten_one_norm_var_smul (c : ‚ÑÇ) (A : Matrix n n ‚ÑÇ) :
    schatten_one_norm_var (c ‚Ä¢ A) = ‚Äñc‚Äñ * schatten_one_norm_var A := by
      unfold schatten_one_norm_var;
      simp +decide [ mul_assoc, Matrix.mul_smul, norm_smul, Real.mul_iSup_of_nonneg, norm_nonneg ]

/-
The space of matrices equipped with the Schatten 1-norm forms a NormedAddCommGroup.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Instance: Matrix n n ‚ÑÇ is a NormedAddCommGroup under the Schatten 1-norm. -/
noncomputable instance instNormedAddCommGroupSchatten : NormedAddCommGroup (Matrix n n ‚ÑÇ) :=
  { instNormSchatten, inferInstanceAs (AddCommGroup (Matrix n n ‚ÑÇ)) with
    dist := fun A B => schatten_one_norm_var (A - B)
    dist_eq := fun A B => rfl
    dist_self := fun A => by
      -- The zero matrix has a Schatten one norm of zero because the trace of the zero matrix is zero, and the operator norm of the zero matrix is zero.
      simp [schatten_one_norm_var]
    dist_comm := fun A B => by
      rw [ show A - B = - ( B - A ) by rw [ neg_sub ], schatten_one_norm_var_neg ]
    dist_triangle := fun A B C => by
      convert schatten_one_norm_var_triangle ( A - B ) ( B - C ) using 1 ; rw [ sub_add_sub_cancel ]
    edist := fun A B => ENNReal.ofReal (schatten_one_norm_var (A - B))
    edist_dist := fun A B => by
      -- The Schatten 1-norm is a real number, and converting it to a real number is the same as the original value.
      apply Eq.refl
    eq_of_dist_eq_zero := fun {A B} h => by
      -- Apply the lemma that states if the Schatten 1-norm of a matrix is zero, then the matrix itself is zero. This is a standard result in functional analysis.
      apply sub_eq_zero.mp; exact (schatten_one_norm_var_eq_zero_iff (A - B)).mp h
  }

/-
The space of matrices equipped with the Schatten 1-norm distance is a Metric Space.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Distance function induced by the Schatten 1-norm. -/
noncomputable def dist_schatten (A B : Matrix n n ‚ÑÇ) : ‚Ñù := schatten_one_norm_var (A - B)

/-- The MetricSpace structure on matrices induced by the Schatten 1-norm. -/
noncomputable instance instMetricSpaceSchatten : MetricSpace (Matrix n n ‚ÑÇ) :=
  { dist := dist_schatten
    dist_self := fun x => by simp [dist_schatten, schatten_one_norm_var_eq_zero_iff]
    dist_comm := fun x y => by simp [dist_schatten]; rw [‚Üê neg_sub, schatten_one_norm_var_neg]
    dist_triangle := fun x y z => by
      simp [dist_schatten]
      have := schatten_one_norm_var_triangle_v2 (x - y) (y - z)
      rw [sub_add_sub_cancel] at this
      exact this
    edist := fun x y => ENNReal.ofReal (dist_schatten x y)
    edist_dist := fun x y => by simp
    eq_of_dist_eq_zero := fun {x y} h => by
      simp [dist_schatten] at h
      rw [schatten_one_norm_var_eq_zero_iff] at h
      exact eq_of_sub_eq_zero h
  }

/-
Definition of Yukawa kernel K(x,y) = exp(-|x-y|/Œæ).
-/
open Real

/-- Yukawa kernel K(x,y) with range Œæ -/
def yukawaKernel {n : ‚Ñï} (xi : ‚Ñù) (x y : Fin n) : ‚Ñù :=
  exp (- |(x : ‚Ñù) - (y : ‚Ñù)| / xi)

/-
Definition of collapse rate kernel Œ≥(x,y).
-/
/-- Collapse rate kernel Œ≥(x,y) = (Œ≥‚ÇÄ/N¬≤) K_Œæ(x,y) Œ∏_causal(x,y) -/
def gammaKernel {n : ‚Ñï} (gamma0 N xi : ‚Ñù) (causal : Fin n ‚Üí Fin n ‚Üí ‚Ñù) (x y : Fin n) : ‚Ñù :=
  (gamma0 / N^2) * yukawaKernel xi x y * causal x y

/-
Definition of entanglement potential Œ¶(x).
-/
open BigOperators

/-- Entanglement potential Œ¶(x) = Œ£_y K(x,y) C(x,y) -/
def entanglementPotential {n : ‚Ñï} (K : Fin n ‚Üí Fin n ‚Üí ‚Ñù) (C : Fin n ‚Üí Fin n ‚Üí ‚Ñù) (x : Fin n) : ‚Ñù :=
  ‚àë y, K x y * C x y

/-
Lemma: Yukawa kernel is non-negative.
-/
lemma yukawaKernel_nonneg {n : ‚Ñï} (xi : ‚Ñù) (hxi : 0 < xi) (x y : Fin n) : 0 ‚â§ yukawaKernel xi x y := 
  exp_nonneg _

/-
Lemma: Yukawa kernel is symmetric.
-/
lemma yukawaKernel_symmetric {n : ‚Ñï} (xi : ‚Ñù) (x y : Fin n) : yukawaKernel xi x y = yukawaKernel xi y x := by
  simp [yukawaKernel, abs_sub_comm]

/-
Fix for double_commutator_identity_proven.
-/
open Matrix Complex

theorem double_commutator_identity_proven_fixed {n : Type} [Fintype n] [DecidableEq n] (L Q : Matrix n n ‚ÑÇ) (hL : L.IsHermitian) :
    dissipator_adjoint L Q = -(1/2 : ‚ÑÇ) ‚Ä¢ (L * (L * Q - Q * L) - (L * Q - Q * L) * L) := by
  exact double_commutator_identity L Q hL

/-
Fix for functional_vanishes_on_powers.
-/
open Matrix Complex BigOperators Topology LinearAlgebra Module

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] [CompleteSpace E]

/-- Helper Lemma: If a continuous linear functional f vanishes on the image of A (i.e. f ‚àò A = 0),
    then f ‚àò A^n = 0 for all n ‚â• 1. -/
theorem functional_vanishes_on_powers_fixed
    (f : E ‚ÜíL[‚ÑÇ] ‚ÑÇ)
    (A : E ‚ÜíL[‚ÑÇ] E)
    (h : f.comp A = 0)
    (n : ‚Ñï)
    (hn : 1 ‚â§ n) :
    f.comp (A ^ n) = 0 := by
      induction hn <;> simp_all +decide [ pow_succ, ‚Üê LinearMap.comp_assoc ];
      simp_all +decide [ ContinuousLinearMap.ext_iff ]

/-
Check Matrix.PosSemidef.trace_nonneg with ComplexOrder opened.
-/
open Matrix Complex BigOperators
open scoped ComplexOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-
Fix for trace_sandwich_nonneg.
-/
open Matrix Complex BigOperators
open scoped ComplexOrder

theorem trace_sandwich_nonneg_fixed {n : Type} [Fintype n] [DecidableEq n]
    (A : Matrix n n ‚ÑÇ) (P : Matrix n n ‚ÑÇ)
    (hP : is_PSD P) :
    0 ‚â§ (trace (A * P * A·¥¥)).re := by
      -- Apply the lemma that states the trace of A * P * A·¥¥ is non-negative when P is positive semi-definite.
      apply trace_sandwich_nonneg A P hP

/-
Fix for schatten_one_norm_var_triangle'.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: Schatten 1-norm (variational) satisfies triangle inequality. -/
lemma schatten_one_norm_var_triangle_proven (A B : Matrix n n ‚ÑÇ) :
    schatten_one_norm_var (A + B) ‚â§ schatten_one_norm_var A + schatten_one_norm_var B := by
  exact schatten_one_norm_var_triangle A B

/-
Fix for trace_eq_zero_of_schatten_zero.
-/
open Matrix Complex BigOperators Topology Filter
open scoped MatrixOrder

variable {n : Type} [Fintype n] [DecidableEq n]

/-- Lemma: If Schatten 1-norm is zero, then trace pairing vanishes for all B. -/
lemma trace_eq_zero_of_schatten_zero_fixed (A : Matrix n n ‚ÑÇ) (h : schatten_one_norm_var A = 0) :
    ‚àÄ B : Matrix n n ‚ÑÇ, (A * B).trace = 0 := by
  have hA : A = 0 := (schatten_one_norm_var_eq_zero_iff A).mp h
  simp [hA]

/-
Proofs for Yukawa kernel nonnegativity and symmetry.
-/
open Real

lemma yukawaKernel_nonneg_proven {n : ‚Ñï} (xi : ‚Ñù) (hxi : 0 < xi) (x y : Fin n) : 0 ‚â§ yukawaKernel xi x y := 
  exp_nonneg _

lemma yukawaKernel_symmetric_proven {n : ‚Ñï} (xi : ‚Ñù) (x y : Fin n) : yukawaKernel xi x y = yukawaKernel xi y x := by
  simp [yukawaKernel, abs_sub_comm]

/-
CPTP maps compose to CPTP.
-/
theorem cptp_comp
  {n : Type} [Fintype n] [DecidableEq n]
  (Œ¶ Œ® : Matrix n n ‚ÑÇ ‚Üí Matrix n n ‚ÑÇ)
  (hŒ¶_cp : IsCompletelyPositive Œ¶) (hŒ¶_tp : IsTracePreserving Œ¶)
  (hŒ®_cp : IsCompletelyPositive Œ®) (hŒ®_tp : IsTracePreserving Œ®) :
  IsCompletelyPositive (Œ¶ ‚àò Œ®) ‚àß IsTracePreserving (Œ¶ ‚àò Œ®) := by
    -- For complete positivity, we need to show that the composition of two CP maps is CP.
    have h_comp_cp : IsCompletelyPositive (Œ¶ ‚àò Œ®) := by
      intro m hm hm' A hA;
      -- Since Œ® is completely positive, map_blocks Œ® A is positive semi-definite.
      have hŒ®_pos : is_PSD (map_blocks Œ® A) := by
        exact hŒ®_cp m A hA;
      convert hŒ¶_cp m ( map_blocks Œ® A ) hŒ®_pos using 1;
    exact ‚ü® h_comp_cp, fun œÅ => by simpa using hŒ¶_tp ( Œ® œÅ ) ‚ñ∏ hŒ®_tp œÅ ‚ü©

/-
Definition of the frozen-coefficient GKSL micro-step as the exponential of the GKSL generator.
-/
noncomputable def gksl_exp_step
  {n : Type} [Fintype n] [DecidableEq n]
  {Œ± : Type} [Fintype Œ±] [DecidableEq Œ±]
  (H : Matrix n n ‚ÑÇ)
  (L : Œ± ‚Üí Matrix n n ‚ÑÇ)
  (c : Œ± ‚Üí ‚Ñù)
  (Œ¥s : ‚Ñù) : Matrix n n ‚ÑÇ ‚Üí Matrix n n ‚ÑÇ :=
  (exp_superop ((Œ¥s : ‚ÑÇ) ‚Ä¢ GKSL_generator_linear H L c)).toFun

/-
Definition of trace as a continuous linear map.
-/
/-- Trace as a continuous linear map. -/
noncomputable def trace_clm {n : Type} [Fintype n] [DecidableEq n] : Matrix n n ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ :=
  LinearMap.toContinuousLinearMap (Matrix.traceLinearMap n ‚ÑÇ ‚ÑÇ)

/-
trace_clm is just trace.
-/
/-- Lemma: trace_clm is just trace. -/
theorem trace_clm_apply {n : Type} [Fintype n] [DecidableEq n] (A : Matrix n n ‚ÑÇ) :
  trace_clm A = A.trace := by
    rfl

/-
Trace is dot product with vec_I.
-/
/-- Vector representing the identity matrix. -/
noncomputable def vec_I {n : Type} [Fintype n] [DecidableEq n] : (n √ó n) ‚Üí ‚ÑÇ :=
  fun ij => if ij.1 = ij.2 then 1 else 0

/-- Lemma: Trace is dot product with vec_I. -/
theorem trace_eq_vec_dot_vec_I
  {n : Type} [Fintype n] [DecidableEq n]
  (A : Matrix n n ‚ÑÇ) :
  A.trace = ‚àë ij : n √ó n, vec_I ij * vec_equiv A ij := by
    -- By definition of vec_equiv, we know that vec_equiv A ‚Üêij is the (i, j) entry of A.
    simp [vec_equiv];
    erw [ Finset.sum_product ];
    simp +decide [ vec_I, Matrix.trace ]

/-
If a superoperator has trace 0, then vec_I is a left null vector of its Liouvillian.
-/
theorem vec_I_left_null_of_trace_zero
  {n : Type} [Fintype n] [DecidableEq n]
  (L : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ)
  (h : ‚àÄ œÅ, (L œÅ).trace = 0) :
  vec_I ·µ•* (superop_equiv L) = 0 := by
    -- By definition of vec_I, we know that vec_I ·µ•* M = 0 implies M is the zero matrix.
    ext i
    simp [vec_I];
    -- By definition of superop_equiv, we have (superop_equiv L)·µ•·µ• i = vec_I ·µ•* (superop_equiv L) i.
    convert h (vec_equiv.symm (Pi.single i 1)) using 1;
    rw [ trace_eq_vec_dot_vec_I ];
    unfold vec_equiv; aesop;

/-
Definition of row_vector_map.
-/
/-- The map A ‚Ü¶ u ·µ•* A as a continuous linear map. -/
noncomputable def row_vector_map
  {n : Type} [Fintype n] [DecidableEq n]
  (u : n ‚Üí ‚ÑÇ) : Matrix n n ‚ÑÇ ‚ÜíL[‚ÑÇ] (n ‚Üí ‚ÑÇ) where
  toFun A := u ·µ•* A
  map_add' A B := by
    ext i; simp +decide [ Matrix.vecMul, Finset.sum_add_distrib ] ;
    -- Apply the linearity of the dot product to split the sum.
    apply dotProduct_add
  map_smul' c A := by
    ext; simp [Matrix.vecMul_smul]
  cont := by
    fun_prop

/-
Left null vector is preserved by powers.
-/
/-- Lemma: If u ·µ•* A = 0, then u ·µ•* (A^k) = 0 for k >= 1. -/
theorem vec_mul_pow_eq_zero
  {n : Type} [Fintype n] [DecidableEq n]
  (u : n ‚Üí ‚ÑÇ)
  (A : Matrix n n ‚ÑÇ)
  (h : u ·µ•* A = 0)
  (k : ‚Ñï)
  (hk : 1 ‚â§ k) :
  u ·µ•* (A ^ k) = 0 := by
    induction hk <;> simp_all +decide [ pow_succ, Matrix.mul_assoc ];
    -- By the properties of matrix multiplication and the induction hypothesis, we can simplify the expression.
    have h_simp : u ·µ•* (A ^ ‚Äπ_‚Ä∫ * A) = (u ·µ•* A ^ ‚Äπ_‚Ä∫) ·µ•* A := by
      ext i; simp +decide [ Matrix.mul_apply, dotProduct ] ;
    aesop

/-
Left null vector is a left fixed point of the exponential.
-/
/-- Lemma: If u ·µ•* A = 0, then u ·µ•* (exp A) = u. -/
theorem vec_mul_exp_eq_self
  {n : Type} [Fintype n] [DecidableEq n]
  (u : n ‚Üí ‚ÑÇ)
  (A : Matrix n n ‚ÑÇ)
  (h : u ·µ•* A = 0) :
  u ·µ•* (NormedSpace.exp ‚ÑÇ A) = u := by
    have h_exp_row : u ·µ•* (NormedSpace.exp ‚ÑÇ A) = ‚àë' k : ‚Ñï, u ·µ•* (A ^ k) / k ! := by
      -- By linearity of matrix multiplication and the fact that the exponential series converges, we can interchange the sum and the matrix multiplication.
      have h_interchange : u ·µ•* (‚àë' k : ‚Ñï, (1 / (k ! : ‚ÑÇ)) ‚Ä¢ A ^ k) = ‚àë' k : ‚Ñï, u ·µ•* ((1 / (k ! : ‚ÑÇ)) ‚Ä¢ A ^ k) := by
        -- By the linearity of matrix multiplication, we can distribute the multiplication over the sum.
        have h_linear : ‚àÄ (s : ‚Ñï ‚Üí Matrix n n ‚ÑÇ), Summable s ‚Üí u ·µ•* (‚àë' k, s k) = ‚àë' k, u ·µ•* s k := by
          intro s hs;
          have h_linear : ‚àÄ (s : ‚Ñï ‚Üí Matrix n n ‚ÑÇ), Summable s ‚Üí u ·µ•* (‚àë' k, s k) = ‚àë' k, u ·µ•* s k := by
            intro s hs
            have h_partial_sums : Filter.Tendsto (fun n => ‚àë k ‚àà Finset.range n, u ·µ•* s k) Filter.atTop (nhds (‚àë' k, u ·µ•* s k)) := by
              refine' ( Summable.hasSum _ ) |> HasSum.tendsto_sum_nat;
              have h_summable : Summable (fun k => s k) := by
                exact hs;
              refine' Pi.summable.mpr _;
              intro x; exact (by
              exact summable_sum fun y _ => Summable.mul_left _ <| Pi.summable.mp ( Pi.summable.mp h_summable y ) x)
            have h_partial_sums : Filter.Tendsto (fun n => u ·µ•* (‚àë k ‚àà Finset.range n, s k)) Filter.atTop (nhds (u ·µ•* (‚àë' k, s k))) := by
              exact Filter.Tendsto.comp ( Continuous.tendsto ( show Continuous fun x : Matrix n n ‚ÑÇ => u ·µ•* x from continuous_const.matrix_vecMul continuous_id' ) _ ) ( hs.hasSum.tendsto_sum_nat );
            exact tendsto_nhds_unique h_partial_sums ( by simpa only [ Matrix.vecMul_sum ] using ‚ÄπTendsto ( fun n_1 => ‚àë k ‚àà Finset.range n_1, u ·µ•* s k ) atTop ( ùìù ( ‚àë' k, u ·µ•* s k ) ) ‚Ä∫ );
          exact h_linear s hs;
        apply h_linear;
        refine' Pi.summable.mpr _;
        intro x;
        refine' Pi.summable.mpr _;
        intro y;
        -- Since $A$ is a matrix, each entry $A_{xy}$ is a complex number, and the series $\sum_{k=0}^{\infty} \frac{(A^k)_{xy}}{k!}$ converges.
        have h_series_conv : Summable (fun k : ‚Ñï => (A ^ k) x y / (k ! : ‚ÑÇ)) := by
          have h_series_conv : Summable (fun k : ‚Ñï => ‚Äñ(A ^ k) x y‚Äñ / (k ! : ‚Ñù)) := by
            have h_series_conv : ‚àÉ C : ‚Ñù, ‚àÄ k : ‚Ñï, ‚Äñ(A ^ k) x y‚Äñ ‚â§ C ^ k := by
              use ‚àë i, ‚àë j, ‚ÄñA i j‚Äñ;
              intro k;
              induction' k with k ih generalizing x y <;> simp_all +decide [ pow_succ, Matrix.mul_apply ];
              ¬∑ by_cases h : x = y <;> aesop;
              ¬∑ refine' le_trans ( norm_sum_le _ _ ) _;
                simp_all +decide [ Finset.mul_sum _ _ _, norm_mul ];
                exact Finset.sum_le_sum fun i _ => le_trans ( mul_le_mul_of_nonneg_right ( ih _ _ ) ( norm_nonneg _ ) ) ( Finset.single_le_sum ( fun j _ => mul_nonneg ( pow_nonneg ( Finset.sum_nonneg fun i _ => Finset.sum_nonneg fun j _ => norm_nonneg ( A i j ) ) _ ) ( norm_nonneg ( A i j ) ) ) ( Finset.mem_univ _ ) );
            exact Summable.of_nonneg_of_le ( fun k => div_nonneg ( norm_nonneg _ ) ( Nat.cast_nonneg _ ) ) ( fun k => div_le_div_of_nonneg_right ( h_series_conv.choose_spec k ) ( Nat.cast_nonneg _ ) ) ( Real.summable_pow_div_factorial _ );
          exact .of_norm <| by simpa using h_series_conv.norm;
        simpa [ div_eq_inv_mul ] using h_series_conv;
      convert h_interchange using 2 <;> norm_num [ div_eq_inv_mul, NormedSpace.exp_eq_tsum ];
      ext; simp +decide [ Matrix.vecMul_smul, smul_eq_mul ] ;
    rw [ h_exp_row, tsum_eq_single 0 ] ; aesop;
    intro k hk; rw [ div_eq_mul_inv ] ; induction k <;> simp_all +decide [ pow_succ, Matrix.mul_assoc ] ;
    have h_ind : ‚àÄ k : ‚Ñï, k ‚â• 1 ‚Üí u ·µ•* (A ^ k) = 0 := by
      intro k hk; exact vec_mul_pow_eq_zero u A h k hk
    exact mul_eq_zero_of_left ( by simpa [ ‚Üê pow_succ ] using h_ind _ ( Nat.succ_pos _ ) ) _

/-
Action of superoperator matrix on vectorized density matrix.
-/
/-- Lemma: Action of superoperator matrix on vectorized density matrix. -/
theorem vec_equiv_apply_superop
  {n : Type} [Fintype n] [DecidableEq n]
  (L : Matrix n n ‚ÑÇ ‚Üí‚Çó[‚ÑÇ] Matrix n n ‚ÑÇ)
  (œÅ : Matrix n n ‚ÑÇ) :
  vec_equiv (L œÅ) = (superop_equiv L) *·µ• (vec_equiv œÅ) := by
    unfold superop_equiv;
    simp +decide [ Matrix.mulVec, Function.comp ]

/-
The frozen GKSL micro-step is trace preserving.
-/
theorem gksl_microstep_tp
  {n : Type} [Fintype n] [DecidableEq n]
  {Œ± : Type} [Fintype Œ±] [DecidableEq Œ±]
  (H : Matrix n n ‚ÑÇ)
  (L : Œ± ‚Üí Matrix n n ‚ÑÇ)
  (c : Œ± ‚Üí ‚Ñù)
  (Œ¥s : ‚Ñù) :
  IsTracePreserving (gksl_exp_step H L c Œ¥s) := by
    -- Let M = Œ¥s ‚Ä¢ superop_equiv (GKSL_generator_linear H L c).
    set M : Matrix (n √ó n) (n √ó n) ‚ÑÇ := Œ¥s ‚Ä¢ superop_equiv (GKSL_generator_linear H L c);
    -- We want to show that vec_I ·µ•* (exp M) = vec_I.
    have h_exp : vec_I ·µ•* (NormedSpace.exp ‚ÑÇ M) = vec_I := by
      -- Since vec_I is a left null vector of M, we have vec_I ·µ•* M = 0.
      have h_null : vec_I ·µ•* M = 0 := by
        have hM : vec_I ·µ•* superop_equiv (GKSL_generator_linear H L c) = 0 := by
          apply vec_I_left_null_of_trace_zero;
          intro œÅ; exact trace_GKSL_generator_zero H L c œÅ
        rw [ Matrix.vecMul_smul ] ; aesop;
      exact vec_mul_exp_eq_self vec_I M h_null
    -- Using the vectorized form, we have vec_equiv (exp_superop (Œ¥s ‚Ä¢ G) œÅ) = exp(M) *·µ• vec_equiv œÅ.
    have h_vec : ‚àÄ œÅ : Matrix n n ‚ÑÇ, vec_equiv (gksl_exp_step H L c Œ¥s œÅ) = NormedSpace.exp ‚ÑÇ M *·µ• vec_equiv œÅ := by
      aesop;
    -- By combining the results from h_exp and h_vec, we can conclude that the trace of the micro-step is equal to the trace of the input matrix.
    intros œÅ
    have h_trace : (gksl_exp_step H L c Œ¥s œÅ).trace = ‚àë ij : n √ó n, vec_I ij * (NormedSpace.exp ‚ÑÇ M *·µ• vec_equiv œÅ) ij := by
      rw [ ‚Üê h_vec, trace_eq_vec_dot_vec_I ];
    have h_trace_simplified : ‚àë ij : n √ó n, vec_I ij * (NormedSpace.exp ‚ÑÇ M *·µ• vec_equiv œÅ) ij = ‚àë ij : n √ó n, (vec_I ·µ•* NormedSpace.exp ‚ÑÇ M) ij * vec_equiv œÅ ij := by
      simp +decide [ Matrix.mulVec, dotProduct ];
      simp +decide [ Matrix.vecMul, dotProduct, Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, Finset.sum_mul ];
      rw [ Finset.sum_comm ];
    rw [ h_trace, h_trace_simplified, h_exp, trace_eq_vec_dot_vec_I ]

/-
Definition of causal locality: gamma(x,y) vanishes if x and y are spacelike separated.
-/
/-- Causal locality of the rate kernel -/
def causal_locality
  {X : Type} [Fintype X]
  (gamma : X ‚Üí X ‚Üí ‚Ñù) (spacelike : X ‚Üí X ‚Üí Prop) : Prop :=
  ‚àÄ x y, spacelike x y ‚Üí gamma x y = 0

/-
The frozen GKSL micro-step is CPTP (assuming CP).
-/
/-- Frozen GKSL micro-step is CPTP.
    Note: The CP property is taken as an assumption (h_cp) because it requires the GKSL theorem which is too heavy to prove here,
    and the tool prevents adding top-level axioms. -/
theorem gksl_microstep_cptp
  {n : Type} [Fintype n] [DecidableEq n]
  {Œ± : Type} [Fintype Œ±] [DecidableEq Œ±]
  (H : Matrix n n ‚ÑÇ) (hH : H.IsHermitian)
  (L : Œ± ‚Üí Matrix n n ‚ÑÇ) (hL : ‚àÄ a, (L a).IsHermitian)
  (c : Œ± ‚Üí ‚Ñù) (hc : ‚àÄ a, 0 ‚â§ c a)
  (h_cp : ‚àÄ Œ¥s ‚â• 0, IsCompletelyPositive (gksl_exp_step H L c Œ¥s)) :
  ‚àÄ Œ¥s ‚â• 0,
    IsCompletelyPositive (gksl_exp_step H L c Œ¥s) ‚àß
    IsTracePreserving (gksl_exp_step H L c Œ¥s) := by
      -- Combine the facts that the micro-step is completely positive and trace preserving.
      intros Œ¥s hŒ¥s
      exact ‚ü®h_cp Œ¥s hŒ¥s, gksl_microstep_tp H L c Œ¥s‚ü©

