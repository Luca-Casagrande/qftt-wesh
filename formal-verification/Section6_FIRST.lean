/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9006958c-7aad-4e33-ba6c-2827d5da66cd
-/

/-
The provided file compiles successfully. I have verified this by checking the existing assumptions and by successfully re-stating and checking the last theorem `theorem_S_BH_asymptotics`. No errors were found.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b7621a52-2d49-4a1b-a229-442b2fe41fd4
-/

/-
Formalization of QFTT-WESH Section 6 (Part 1) - Black Hole Entropy.
This module defines the kinematic Hilbert space H_kin, the swap operator G_xy, and the even projection E_even.
It proves Theorem 6.1 (Asymptotic Halving) showing the trace ratio converges to 1/2.
It defines the physical degrees of freedom N_phys and proves the universal 1/4 prefactor corollary.
Finally, it defines the Bekenstein-Hawking entropy S_BH and proves its asymptotic behavior.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Module.finrank

/-
Define H_kin, G_xy, E_even, and P_phys.
E_even is the projection onto the symmetric subspace: (1 + G_xy)/2.
P_phys is the composition of E_even and P_RAQ.
-/
open TensorProduct LinearMap

variable (D : ‚Ñï)
variable (H : Type) [NormedAddCommGroup H] [InnerProductSpace ‚ÑÇ H] [FiniteDimensional ‚ÑÇ H]
variable (hD : Module.finrank ‚ÑÇ H = D)

/-- The kinematic Hilbert space H_kin = H ‚äó H -/
abbrev H_kin := H ‚äó[‚ÑÇ] H

/-- The swap operator G_xy -/
def G_xy : H_kin H ‚Üí‚Çó[‚ÑÇ] H_kin H := TensorProduct.comm ‚ÑÇ H H

/-- The even projection E_even = (1 + G_xy)/2 -/
noncomputable def E_even : H_kin H ‚Üí‚Çó[‚ÑÇ] H_kin H :=
  (2 : ‚ÑÇ)‚Åª¬π ‚Ä¢ (LinearMap.id + G_xy H)

/-- The physical projector P_phys = E_even ‚àò P_RAQ -/
noncomputable def P_phys (P_RAQ : H_kin H ‚Üí‚Çó[‚ÑÇ] H_kin H) : H_kin H ‚Üí‚Çó[‚ÑÇ] H_kin H :=
  (E_even H) ‚àò‚Çó P_RAQ

/-
The dimension of H_kin is D * D.
-/
lemma finrank_tensor_eq_sq (hD : Module.finrank ‚ÑÇ H = D) :
    Module.finrank ‚ÑÇ (H_kin H) = D * D := by
  erw [ Module.finrank_tensorProduct ] ; aesop

/-
The trace of the identity on H_kin is D^2.
Proof: trace(id) = dim(H_kin) = D*D = D^2.
-/
lemma trace_id_tensor (hD : Module.finrank ‚ÑÇ H = D) :
    LinearMap.trace ‚ÑÇ (H_kin H) LinearMap.id = (D : ‚ÑÇ) ^ 2 := by
      erw [ sq, LinearMap.trace_id ] ; aesop

/-
The trace of the swap operator G_xy on H ‚äó H is equal to the dimension D of H.
Proof: This is a standard result. The swap operator maps u ‚äó v to v ‚äó u. Taking the trace in a basis e_i ‚äó e_j gives sum <e_i ‚äó e_j, e_j ‚äó e_i> = sum delta_ij = dim H.
-/
lemma trace_swap (hD : Module.finrank ‚ÑÇ H = D) :
    LinearMap.trace ‚ÑÇ (H_kin H) (G_xy H) = (D : ‚ÑÇ) := by
  unfold G_xy;
  -- Let $e_i$ be an orthonormal basis for $H$.
  obtain ‚ü®e, he‚ü© : ‚àÉ e : OrthonormalBasis (Fin (Module.finrank ‚ÑÇ H)) ‚ÑÇ H, True := by
    simp +zetaDelta at *;
    exact ‚ü® by exact? ‚ü©;
  rw [ ‚Üê hD, LinearMap.trace_eq_matrix_trace ‚ÑÇ ( e.toBasis.tensorProduct e.toBasis ) ];
  simp +decide [ LinearMap.toMatrix_apply, Matrix.trace ];
  erw [ Finset.sum_product ] ; aesop

/-
Theorem 6.1 (Asymptotic Halving): For H_kin = H_out ‚äó H_in with dim H_out = dim H_in = D, the trace of the even projection E_even divided by the trace of the identity is (D(D+1)/2) / D^2.
Proof:
Tr[E_even] = Tr[(1 + G_xy)/2] = (1/2) * (Tr[1] + Tr[G_xy])
           = (1/2) * (D^2 + D) = D(D+1)/2.
Tr[1] = D^2.
Ratio = (D(D+1)/2) / D^2.
-/
theorem theorem_6_1_asymptotic_halving (hD : Module.finrank ‚ÑÇ H = D) :
    (LinearMap.trace ‚ÑÇ (H_kin H) (E_even H)) / (LinearMap.trace ‚ÑÇ (H_kin H) (LinearMap.id)) =
    (D * (D + 1) / 2 : ‚ÑÇ) / (D ^ 2 : ‚ÑÇ) := by
      -- Using the linearity of the trace, we can split the trace of E_even into the sum of the traces of (1/2)*id and (1/2)*G_xy.
      have h_trace_split : (LinearMap.trace ‚ÑÇ (H_kin H)) (E_even H) = (1 / 2 : ‚ÑÇ) * (LinearMap.trace ‚ÑÇ (H_kin H)) (LinearMap.id) + (1 / 2 : ‚ÑÇ) * (LinearMap.trace ‚ÑÇ (H_kin H)) (G_xy H) := by
        unfold E_even;
        norm_num [ mul_add ];
      by_cases hD : D = 0 <;> simp_all +decide [ sq, mul_div_mul_right ];
      rw [ show ( LinearMap.trace ‚ÑÇ ( H_kin H ) ) ( G_xy H ) = ( D : ‚ÑÇ ) by exact? ] ; ring

/-
Define factor_bipartite = 1/2 and factor_RAQ(D) = (D(D+1)/2) / D^2.
-/
open Filter Topology

/-- Bipartite pairing factor: 1/2 -/
noncomputable def factor_bipartite : ‚Ñù := 1 / 2

/-- RAQ even projection factor as a function of D: (D(D+1)/2) / D^2 -/
noncomputable def factor_RAQ (D : ‚Ñï) : ‚Ñù := (D * (D + 1) / 2 : ‚Ñù) / (D ^ 2 : ‚Ñù)

/-
Define N_phys(D) = factor_bipartite * factor_RAQ(D) * (A/Œæ^2).
Theorem: N_phys(D) tends to (1/4) * (A/Œæ^2) as D tends to infinity.
-/
variable (A Œæ : ‚Ñù)

/-- N_phys = factor_bipartite * factor_RAQ * (A/Œæ¬≤) -/
noncomputable def N_phys (D : ‚Ñï) : ‚Ñù := factor_bipartite * factor_RAQ D * (A / Œæ ^ 2)

/-- Corollary (Universal 1/4 Prefactor): N_phys ‚Üí (1/4) A/Œæ¬≤ as D ‚Üí ‚àû -/
theorem corollary_universal_prefactor :
    Filter.Tendsto (fun D => N_phys A Œæ D) Filter.atTop (nhds ((1 / 4) * (A / Œæ ^ 2))) := by
  -- We can factor out the constant factor (D(D+1)/(2D^2)) * (1/2) and take the limit as D tends to infinity.
  have h_factor : Filter.Tendsto (fun D : ‚Ñï => (D * (D + 1) / 2 : ‚Ñù) / (D ^ 2) * (1 / 2)) Filter.atTop (ùìù ((1 / 4) : ‚Ñù)) := by
    field_simp;
    ring_nf;
    simpa using Filter.Tendsto.add ( tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with D hD; aesop ) ) ( tendsto_inverse_atTop_nhds_zero_nat.mul tendsto_const_nhds );
  convert h_factor.mul_const ( A / Œæ ^ 2 ) using 2 ; unfold N_phys ; norm_num ; ring_nf;
  unfold factor_bipartite factor_RAQ; ring_nf; aesop;

/-
Define N_phys_limit = (1/4) * A / Œæ^2.
Define S_BH = N_phys_limit * s_bar.
-/
open Asymptotics Filter Topology

variable (A Œæ : ‚Ñù)
variable (s_bar : ‚Ñù ‚Üí ‚Ñù) -- s_bar depends on A

/-- The limiting value of N_phys as D ‚Üí ‚àû -/
noncomputable def N_phys_limit : ‚Ñù := (1 / 4) * (A / Œæ ^ 2)

/-- Bekenstein-Hawking Entropy S_BH = N_phys_limit * s_bar -/
noncomputable def S_BH : ‚Ñù := N_phys_limit A Œæ * s_bar A

/-
Theorem: If sÃÑ = 1 + O(Œæ¬≤/A), then S_BH = A/(4Œæ¬≤) + O(1) as A ‚Üí ‚àû.
Proof:
S_BH = (1/4)(A/Œæ¬≤) * sÃÑ
     = (1/4)(A/Œæ¬≤) * (1 + (sÃÑ - 1))
     = A/(4Œæ¬≤) + (1/4)(A/Œæ¬≤) * (sÃÑ - 1)
So S_BH - A/(4Œæ¬≤) = (1/4)(A/Œæ¬≤) * (sÃÑ - 1).
Given sÃÑ - 1 = O(Œæ¬≤/A),
(A/Œæ¬≤) * (sÃÑ - 1) = (A/Œæ¬≤) * O(Œæ¬≤/A) = O(1).
Thus S_BH - A/(4Œæ¬≤) = O(1).
-/
theorem theorem_S_BH_asymptotics (h_s_bar : (fun A => s_bar A - 1) =O[Filter.atTop] (fun A => Œæ ^ 2 / A)) :
    (fun A => S_BH A Œæ s_bar - A / (4 * Œæ ^ 2)) =O[Filter.atTop] (fun _ => (1 : ‚Ñù)) := by
  unfold S_BH N_phys_limit;
  have := h_s_bar.mul ( show ( fun A => A / Œæ ^ 2 ) =O[Filter.atTop] ( fun A => A ) from ?_ );
  ¬∑ convert this.const_mul_left ( 1 / 4 ) |> ( ¬∑.trans ( ?_ ) ) using 1;
    ¬∑ exact funext fun x => by ring;
    ¬∑ rw [ Asymptotics.isBigO_iff ];
      norm_num +zetaDelta at *;
      exact ‚ü® Œæ ^ 2, 1, fun x hx => by rw [ div_mul_cancel‚ÇÄ _ ( by positivity ) ] ‚ü©;
  ¬∑ norm_num [ Asymptotics.isBigO_iff ];
    exact ‚ü® 1 / Œæ ^ 2, 0, fun x hx => by ring_nf; norm_num ‚ü©

#check H_kin
#check G_xy
#check E_even
#check P_phys
#check theorem_6_1_asymptotic_halving
#check N_phys
#check corollary_universal_prefactor
#check S_BH
#check theorem_S_BH_asymptotics

#check Asymptotics.IsBigO
#check Asymptotics.IsLittleO
#check nhds

/-
Theorem: If sÃÑ = 1 + O(Œæ¬≤/A), then S_BH = A/(4Œæ¬≤) + O(1) as A ‚Üí ‚àû.
-/
theorem theorem_S_BH_asymptotics' (Œæ : ‚Ñù) (s_bar : ‚Ñù ‚Üí ‚Ñù)
    (h_s_bar : (fun A => s_bar A - 1) =O[Filter.atTop] (fun A => Œæ ^ 2 / A)) :
    (fun A => S_BH A Œæ s_bar - A / (4 * Œæ ^ 2)) =O[Filter.atTop] (fun _ => (1 : ‚Ñù)) := by
      exact?