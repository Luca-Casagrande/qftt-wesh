/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e26af058-221b-4859-8e1c-021b29f8d2b8
-/

/-
The file `Section 5 LEAN.txt` compiles successfully. All declarations, including the main results `theorem_5_1_fixed_point`, `theorem_5_4_einstein_emergence`, and `theorem_5_5_consistency_limit`, have been verified and added to the workspace. The proofs provided in the file are correct and accepted by the kernel.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the commutator of two continuous linear operators.
-/
/-- The commutator of two continuous linear operators. -/
noncomputable def comm_op {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] (A B : H →L[ℂ] H) : H →L[ℂ] H := A * B - B * A

/-
Definition of the standard Lindblad dissipator adjoint acting on an observable Q.
-/
/-- The standard Lindblad dissipator adjoint acting on an observable Q.
    D†[L](Q) = L† Q L - 1/2 {L† L, Q} -/
noncomputable def dissipator_adjoint {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] (L : H →L[ℂ] H) (Q : H →L[ℂ] H) : H →L[ℂ] H :=
  (ContinuousLinearMap.adjoint L) * Q * L -
  (1 / 2 : ℂ) • ((ContinuousLinearMap.adjoint L * L) * Q + Q * (ContinuousLinearMap.adjoint L * L))

/-
Theorem stating that for Hermitian L, the dissipator adjoint can be written as a double commutator.
-/
/-- For Hermitian L, the dissipator adjoint can be written as a double commutator. -/
theorem dissipator_adjoint_eq_double_commutator {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] (L Q : H →L[ℂ] H) (hL : ContinuousLinearMap.adjoint L = L) :
    dissipator_adjoint L Q = - (1 / 2 : ℂ) • comm_op L (comm_op L Q) := by
      simp [dissipator_adjoint];
      ext x; norm_num [ hL, comm_op ] ; ring;
      norm_num [ two_smul ] ; abel_nf;
      norm_num [ two_smul, add_smul ] ; abel_nf;
      rw [ ← smul_assoc ] ; norm_num

/-
Lemma stating that the trace of the commutator of two operators is zero.
-/
lemma trace_comm_zero {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] (A B : H →L[ℂ] H) : LinearMap.trace ℂ H (comm_op A B) = 0 := by
  convert LinearMap.trace_mul_comm _ _;
  rotate_left;
  exact ℂ;
  exact inferInstance;
  exact H;
  exact?;
  exact?;
  exact A.toLinearMap * B.toLinearMap - B.toLinearMap * A.toLinearMap;
  constructor <;> intro h;
  · intro g; rw [ ← LinearMap.trace_mul_comm ] ;
  · convert h 1 using 1 ; simp +decide [ comm_op ];
    rw [ ← LinearMap.trace_mul_comm ] ; ring

/-
Lemma stating that the trace of the Hamiltonian term Q * i[H, Q] is zero.
-/
lemma trace_hamiltonian_term {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] (H_eff Q : H →L[ℂ] H) :
  LinearMap.trace ℂ H (Q * (Complex.I • comm_op H_eff Q)) = 0 := by
    -- Apply the fact that the trace of a commutator is zero.
    have h_comm : LinearMap.trace ℂ H (Q * (comm_op H_eff Q)) = 0 := by
      -- By the properties of the trace, we can rearrange $Q[H, Q]$ to $[QH, Q]$.
      have h_comm : Q * (comm_op H_eff Q) = comm_op (Q * H_eff) Q := by
        unfold comm_op; ext; simp +decide [ mul_assoc ] ;
      convert trace_comm_zero ( Q * H_eff ) Q;
      exact?;
    simp_all +decide [ mul_assoc, LinearMap.trace ]

/-
Lemma stating that the trace of the dissipator term Q * D†[L](Q) is equal to -1/2 times the square of the Hilbert-Schmidt norm of the commutator [L, Q].
-/
lemma trace_dissipator_term {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] (L Q : H →L[ℂ] H) (hL : ContinuousLinearMap.adjoint L = L) (hQ : ContinuousLinearMap.adjoint Q = Q) :
  LinearMap.trace ℂ H (Q * dissipator_adjoint L Q) = - (1/2 : ℂ) * LinearMap.trace ℂ H (ContinuousLinearMap.adjoint (comm_op L Q) * (comm_op L Q)) := by
    -- Use dissipator_adjoint_eq_double_commutator: D†[L](Q) = -1/2 [L, [L, Q]].
    have h_dissipator : dissipator_adjoint L Q = - (1 / 2 : ℂ) • comm_op L (comm_op L Q) := by
      exact?;
    -- Use cyclicity: trace(Q [L, K]) = trace([Q, L] K) = - trace([L, Q] K).
    have h_cyclicity : LinearMap.trace ℂ H (Q * (comm_op L (comm_op L Q))) = -LinearMap.trace ℂ H ((comm_op L Q) * (comm_op L Q)) := by
      have h_cyclicity : LinearMap.trace ℂ H (Q * (L * (L * Q - Q * L) - (L * Q - Q * L) * L)) = LinearMap.trace ℂ H ((L * Q - Q * L) * (L * Q - Q * L)) * (-1) := by
        have h_cyclicity : ∀ (A B C : H →ₗ[ℂ] H), LinearMap.trace ℂ H (A * (B * C - C * B)) = LinearMap.trace ℂ H ((C * A - A * C) * B) := by
          simp +decide [ mul_sub, sub_mul, ← mul_assoc ];
          intro A B C; rw [ ← LinearMap.trace_mul_comm ] ; simp +decide [ mul_assoc ] ;
        convert congr_arg Neg.neg ( h_cyclicity Q ( L * Q - Q * L ) L ) using 1 <;> simp +decide [ mul_assoc, sub_mul, mul_sub ];
      convert h_cyclicity using 1 ; norm_num [ mul_assoc, sub_mul, mul_sub ] ; ring!;
      unfold comm_op; norm_num [ mul_assoc, sub_mul, mul_sub ] ; ring!;
    -- Since L and Q are Hermitian, [L, Q]† = (LQ - QL)† = QL - LQ = -[L, Q].
    have h_comm_adjoint : ContinuousLinearMap.adjoint (comm_op L Q) = -comm_op L Q := by
      unfold comm_op;
      ext; simp +decide [ hL, hQ, ContinuousLinearMap.adjoint ] ;
      congr 1;
      · refine' ( InnerProductSpace.toDual ℂ H ).injective _;
        ext; simp +decide [ *, ContinuousLinearMap.comp_apply, innerSL_apply ];
        rw [ ← ContinuousLinearMap.adjoint_inner_right, ← ContinuousLinearMap.adjoint_inner_right ] ; aesop;
      · refine' ( InnerProductSpace.toDual ℂ H ).symm_apply_eq.mpr _;
        have := ContinuousLinearMap.adjoint_inner_left Q; have := ContinuousLinearMap.adjoint_inner_left L; aesop;
    aesop

/-
Lemma stating that the trace of A† A is zero if and only if A is zero, for a continuous linear map A on a finite-dimensional Hilbert space.
-/
lemma trace_adjoint_mul_self_eq_zero_iff {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] (A : H →L[ℂ] H) :
  LinearMap.trace ℂ H (ContinuousLinearMap.adjoint A * A) = 0 ↔ A = 0 := by
    -- Since $A$ is a continuous linear map, we can apply the fact that the trace of a positive operator is zero if and only if the operator is zero.
    have h_pos : ∀ (A : H →L[ℂ] H), (LinearMap.trace ℂ H) (↑((ContinuousLinearMap.adjoint : (H →L[ℂ] H) → H →L[ℂ] H) A) * (↑A : H →ₗ[ℂ] H)) = 0 → A = 0 := by
      intro A hA_zero
      have h_hilbert_schmidt : ∑ i : Fin (Module.finrank ℂ H), inner ℂ (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i)) (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i)) = 0 := by
        convert hA_zero using 1;
        simp +decide [ LinearMap.trace_eq_matrix_trace ℂ ( stdOrthonormalBasis ℂ H ).toBasis ];
        simp +decide [ LinearMap.toMatrix_apply, Matrix.trace ];
        simp +decide [ ContinuousLinearMap.adjoint_inner_left, OrthonormalBasis.repr_apply_apply ];
        simp +decide [ ContinuousLinearMap.adjoint_inner_right ];
      -- Since the sum of the squares of the norms of the images of the basis vectors under A is zero, each individual norm must be zero.
      have h_norm_zero : ∀ i : Fin (Module.finrank ℂ H), ‖A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i)‖ = 0 := by
        simp_all +decide [ inner_self_eq_norm_sq_to_K ];
        norm_cast at h_hilbert_schmidt; simp_all +decide [ Finset.sum_eq_zero_iff_of_nonneg, sq_nonneg ] ;
      ext x; rw [ ← ( stdOrthonormalBasis ℂ H ).sum_repr x ] ; simp_all +decide [ Finset.sum_apply, Finset.mul_sum _ _ _ ] ;
    specialize h_pos A ; aesop

/-
Definition of the adjoint GKSL generator acting on an observable Q.
-/
/-- The adjoint GKSL generator acting on an observable Q.
    L†[Q] = i[H_eff, Q] + ∑_k c_k (L_k Q L_k - 1/2 {L_k^2, Q})
    We assume L_k are Hermitian, so L_k† = L_k. -/
noncomputable def gksl_generator_adjoint
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (H_eff : H →L[ℂ] H)
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (Q : H →L[ℂ] H) : H →L[ℂ] H :=
  (Complex.I • comm_op H_eff Q) +
  ∑ i, (c i : ℂ) • dissipator_adjoint (L i) Q

/-
Theorem: WESH-Noether Conservation (Finite Dimensional).
If L_k are Hermitian and c_k > 0, then L†[Q] = 0 iff [H_eff, Q] = 0 and [L_k, Q] = 0 for all k.
-/
/-- Theorem: WESH-Noether Conservation (Finite Dimensional).
    If L_k are Hermitian and c_k > 0, then L†[Q] = 0 iff [H_eff, Q] = 0 and [L_k, Q] = 0 for all k. -/
theorem wesh_noether_finite_dim
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (H_eff : H →L[ℂ] H)
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (Q : H →L[ℂ] H)
    (hL : ∀ i, ContinuousLinearMap.adjoint (L i) = L i)
    (hc : ∀ i, 0 < c i)
    (hQ : ContinuousLinearMap.adjoint Q = Q) :
    gksl_generator_adjoint H_eff L c Q = 0 ↔
    (comm_op H_eff Q = 0 ∧ ∀ i, comm_op (L i) Q = 0) := by
      -- Apply the `trace_dissipator_term` lemma to each term in the sum.
      have h_trace_dissipator : ∀ i, LinearMap.trace ℂ H (Q * (dissipator_adjoint (L i) Q)) = - (1/2 : ℂ) * LinearMap.trace ℂ H (ContinuousLinearMap.adjoint (comm_op (L i) Q) * (comm_op (L i) Q)) := by
        intro i; exact (by
        convert trace_dissipator_term ( L i ) Q ( hL i ) hQ using 1);
      constructor;
      · -- By linearity of the trace, we can pull the summation out of the trace.
        intro h
        have h_sum : LinearMap.trace ℂ H (Q * (Complex.I • comm_op H_eff Q)) + ∑ i, c i • LinearMap.trace ℂ H (Q * (dissipator_adjoint (L i) Q)) = 0 := by
          convert congr_arg ( fun f : H →L[ℂ] H => LinearMap.trace ℂ H ( Q * f ) ) h using 1;
          · unfold gksl_generator_adjoint; simp +decide [ mul_add, add_mul, Finset.sum_add_distrib, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _ ] ;
          · simp +decide [ LinearMap.trace ];
        -- Since $\operatorname{Tr}(A^\dagger A) \geq 0$ for any $A$, we have $\operatorname{Tr}([L_i, Q]^\dagger [L_i, Q]) \geq 0$.
        have h_nonneg : ∀ i, 0 ≤ (LinearMap.trace ℂ H (ContinuousLinearMap.adjoint (comm_op (L i) Q) * (comm_op (L i) Q))).re := by
          intro i;
          -- By definition of the trace, we know that $\operatorname{Tr}(A^\dagger A) = \sum_{j} \langle A e_j, A e_j \rangle$ for any orthonormal basis $\{e_j\}$.
          have h_trace_def : ∀ A : H →L[ℂ] H, LinearMap.trace ℂ H (ContinuousLinearMap.adjoint A * A) = ∑ j, inner ℂ (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) j)) (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) j)) := by
            intro A;
            convert LinearMap.trace_eq_matrix_trace ℂ ( stdOrthonormalBasis ℂ H |> OrthonormalBasis.toBasis ) _ using 1;
            simp +decide [ LinearMap.toMatrix_apply, Matrix.trace ];
            simp +decide [ ContinuousLinearMap.adjoint_inner_left, OrthonormalBasis.repr_apply_apply ];
            simp +decide [ ContinuousLinearMap.adjoint_inner_right ];
          simp_all +decide [ inner_self_eq_norm_sq_to_K ];
          exact Finset.sum_nonneg fun _ _ => by norm_cast; positivity;
        -- Since $\operatorname{Tr}(A^\dagger A) \geq 0$ for any $A$, we have $\operatorname{Tr}([L_i, Q]^\dagger [L_i, Q]) = 0$ for all $i$.
        have h_zero : ∀ i, LinearMap.trace ℂ H (ContinuousLinearMap.adjoint (comm_op (L i) Q) * (comm_op (L i) Q)) = 0 := by
          have h_zero : ∑ i, c i • (LinearMap.trace ℂ H (ContinuousLinearMap.adjoint (comm_op (L i) Q) * (comm_op (L i) Q))).re = 0 := by
            have h_trace_hamiltonian : LinearMap.trace ℂ H (Q * (Complex.I • comm_op H_eff Q)) = 0 := by
              convert trace_hamiltonian_term H_eff Q using 1;
            simp_all +decide [ Complex.ext_iff, Finset.mul_sum _ _ _ ];
            convert congr_arg ( fun x : ℝ => x * 2 ) h_sum.1 using 1 <;> norm_num [ Finset.sum_mul _ _ _ ] ; ring;
          rw [ Finset.sum_eq_zero_iff_of_nonneg ] at h_zero;
          · simp_all +decide [ ne_of_gt ];
            intro i;
            have h_zero : ∀ A : H →L[ℂ] H, (LinearMap.trace ℂ H (ContinuousLinearMap.adjoint A * A)).im = 0 := by
              intro A;
              have h_trace_real : ∀ A : H →L[ℂ] H, (LinearMap.trace ℂ H (ContinuousLinearMap.adjoint A * A)).im = 0 := by
                intro A
                have h_trace_real : ∀ (A : H →L[ℂ] H), (LinearMap.trace ℂ H (ContinuousLinearMap.adjoint A * A)) = ∑ i, (inner ℂ (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i)) (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i))) := by
                  intro A;
                  rw [ LinearMap.trace_eq_matrix_trace ℂ ( stdOrthonormalBasis ℂ H ).toBasis ];
                  simp +decide [ LinearMap.toMatrix_apply, Matrix.trace ];
                  simp +decide [ ContinuousLinearMap.adjoint_inner_left, OrthonormalBasis.repr_apply_apply ];
                  simp +decide [ ContinuousLinearMap.adjoint_inner_right ]
                simp_all +decide [ inner_self_eq_norm_sq_to_K ];
                norm_cast ; norm_num;
              exact h_trace_real A;
            exact Complex.ext ( by aesop ) ( by aesop );
          · exact fun i _ => mul_nonneg ( le_of_lt ( hc i ) ) ( h_nonneg i );
        -- Since $\operatorname{Tr}(A^\dagger A) = 0$ implies $A = 0$, we have $[L_i, Q] = 0$ for all $i$.
        have h_comm_zero : ∀ i, comm_op (L i) Q = 0 := by
          intro i;
          exact?;
        simp_all +decide [ Complex.ext_iff, gksl_generator_adjoint ];
        simp_all +decide [ dissipator_adjoint_eq_double_commutator, comm_op ];
      · intro h_comm
        simp [h_comm, gksl_generator_adjoint];
        unfold dissipator_adjoint; simp_all +decide [ sub_eq_iff_eq_add, comm_op ] ;
        simp_all +decide [ mul_assoc, ContinuousLinearMap.ext_iff ];
        simp +decide [ ← two_smul ℂ, smul_sub, sub_eq_zero ]

/-
Definition of the contribution to the time production functional from a single jump operator L.
-/
/-- The contribution to the time production functional from a single jump operator L.
    Gamma_L = Tr(L rho L†) -/
noncomputable def gamma_contribution {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] (L : H →L[ℂ] H) (rho : H →L[ℂ] H) : ℝ :=
  (LinearMap.trace ℂ H (L * rho * ContinuousLinearMap.adjoint L)).re

/-
Lemma stating that the contribution to the time production functional from a single jump operator is non-negative if the state is positive.
-/
/-- Lemma 2.2 (Part 1): Gamma contribution is non-negative for positive rho. -/
theorem gamma_contribution_nonneg {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] (L : H →L[ℂ] H) (rho : H →L[ℂ] H) (h_rho : ContinuousLinearMap.IsPositive rho) :
    0 ≤ gamma_contribution L rho := by
      -- Since $\rho$ is positive, we have $\rho = B^* B$ for some $B$.
      obtain ⟨B, hB⟩ : ∃ B : H →L[ℂ] H, rho = ContinuousLinearMap.adjoint B * B := by
        have h_sqrt : ∃ B : H →L[ℂ] H, rho = B.adjoint * B := by
          have h_pos : 0 ≤ rho := by
            exact?
          exact?
        generalize_proofs at *;
        exact h_sqrt;
      -- Substitute $\rho = B^* B$ into the expression.
      have h_subst : LinearMap.trace ℂ H (L * (ContinuousLinearMap.adjoint B * B) * (ContinuousLinearMap.adjoint L)) = LinearMap.trace ℂ H ((L * ContinuousLinearMap.adjoint B) * (ContinuousLinearMap.adjoint (L * ContinuousLinearMap.adjoint B))) := by
        simp +decide [ mul_assoc, ContinuousLinearMap.adjoint ];
        congr 2 ; ext ; simp +decide [ ContinuousLinearMap.adjointAux ];
        ext; simp +decide [ ContinuousLinearMap.comp_apply, innerSL_apply ];
        rw [ ← ContinuousLinearMap.adjoint_inner_right ];
        simp +decide [ ContinuousLinearMap.adjoint ];
      -- The trace of a positive operator is non-negative.
      have h_trace_nonneg : ∀ (A : H →L[ℂ] H), 0 ≤ Complex.re (LinearMap.trace ℂ H ((ContinuousLinearMap.adjoint A) * A)) := by
        intro A
        have h_trace_nonneg : Complex.re (LinearMap.trace ℂ H ((ContinuousLinearMap.adjoint A) * A)) = ∑ i, Complex.re (inner ℂ (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i)) (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i))) := by
          have h_trace_nonneg : LinearMap.trace ℂ H ((ContinuousLinearMap.adjoint A) * A) = ∑ i, inner ℂ (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i)) (A (OrthonormalBasis.toBasis (stdOrthonormalBasis ℂ H) i)) := by
            convert LinearMap.trace_eq_matrix_trace ℂ ( stdOrthonormalBasis ℂ H |> OrthonormalBasis.toBasis ) _ using 1;
            simp +decide [ LinearMap.toMatrix_apply, Matrix.trace ];
            simp +decide [ ContinuousLinearMap.adjoint_inner_left, OrthonormalBasis.repr_apply_apply ];
            simp +decide [ ContinuousLinearMap.adjoint_inner_right ];
          rw [ h_trace_nonneg, Complex.re_sum ];
        simp_all +decide [ inner_self_eq_norm_sq_to_K ];
        exact Finset.sum_nonneg fun _ _ => by norm_cast; positivity;
      convert h_trace_nonneg ( L * ContinuousLinearMap.adjoint B ) using 1;
      convert congr_arg Complex.re h_subst using 1;
      · unfold gamma_contribution; simp +decide [ hB ] ;
        congr! 2;
      · rw [ LinearMap.trace_mul_comm ];
        rfl

/-
Definition of the total time production functional Gamma.
-/
/-- The total time production functional Gamma.
    Gamma = sum_k c_k Tr(L_k rho L_k†)
    where c_k > 0 are rates. -/
noncomputable def gamma_functional
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (rho : H →L[ℂ] H) : ℝ :=
  ∑ i, c i * gamma_contribution (L i) rho

/-
Definition of the hazard rate at time s, given the state rho(s).
-/
/-- The hazard rate at time s, given the state rho(s). -/
noncomputable def hazard_rate
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (rho : ℝ → H →L[ℂ] H)
    (s : ℝ) : ℝ :=
  gamma_functional L c (rho s)

/-
Definition of the survival function at time t.
-/
/-- The survival function at time t: probability that no event has occurred up to time t.
    S(t) = exp(- integral_0^t lambda(s) ds) -/
noncomputable def survival_function
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (rho : ℝ → H →L[ℂ] H)
    (t : ℝ) : ℝ :=
  Real.exp (- ∫ s in Set.Ioc 0 t, hazard_rate L c rho s)

/-
Lemma 2.3: If the hazard rate is initially positive and continuous, then the survival function decays.
-/
/-- Lemma 2.3: If the hazard rate is initially positive and continuous,
    then the survival function decays (probability of event is positive). -/
theorem lemma_2_3_finite_waiting_time
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (rho : ℝ → H →L[ℂ] H)
    (h_cont : Continuous (fun s => hazard_rate L c rho s))
    (h_init : 0 < hazard_rate L c rho 0) :
    ∃ δ > 0, survival_function L c rho δ < 1 := by
      -- Since the hazard rate is continuous and positive at 0, there exists a δ > 0 such that the hazard rate is positive for all s in [0, δ].
      obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ s ∈ Set.Icc 0 δ, 0 < hazard_rate L c rho s := by
        have := Metric.continuous_iff.1 h_cont 0;
        exact Exists.elim ( this _ h_init ) fun δ hδ => ⟨ δ / 2, half_pos hδ.1, fun s hs => by linarith [ abs_lt.mp ( hδ.2 s ( abs_lt.mpr ⟨ by linarith [ hs.1 ], by linarith [ hs.2 ] ⟩ ) ) ] ⟩;
      -- Since the hazard rate is positive on [0, δ], the integral of the hazard rate over [0, δ] is positive.
      have h_integral_pos : 0 < ∫ s in Set.Ioc 0 δ, hazard_rate L c rho s := by
        rw [ MeasureTheory.integral_pos_iff_support_of_nonneg_ae ];
        · simp +decide [ Function.support, hδ_pos ];
          exact lt_of_lt_of_le ( by simp +decide [ hδ_pos ] ) ( MeasureTheory.measure_mono ( show Set.Ioc 0 δ ⊆ { x : ℝ | ¬hazard_rate L c rho x = 0 } ∩ Set.Ioc 0 δ from fun x hx => ⟨ ne_of_gt ( hδ x ⟨ hx.1.le, hx.2 ⟩ ), hx ⟩ ) );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with s hs using le_of_lt ( hδ s ⟨ hs.1.le, hs.2 ⟩ );
        · exact h_cont.integrableOn_Ioc;
      refine' ⟨ δ, hδ_pos, _ ⟩;
      refine' Real.exp_lt_one_iff.mpr _;
      linarith

/-
Definition of a quantum state.
-/
/-- A continuous linear map is a quantum state if it is positive and has trace 1. -/
def is_state {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] (rho : H →L[ℂ] H) : Prop :=
  ContinuousLinearMap.IsPositive rho ∧ LinearMap.trace ℂ H (rho : H →ₗ[ℂ] H) = 1

/-
Theorem stating that the set of quantum states is closed.
-/
/-- The set of quantum states is closed. -/
theorem isClosed_set_of_states {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] : IsClosed {rho : H →L[ℂ] H | is_state rho} := by
  -- The set of positive operators is closed.
  have h_pos_closed : IsClosed {rho : H →L[ℂ] H | ContinuousLinearMap.IsPositive rho} := by
    refine' IsClosed.inter _ _;
    · exact isClosed_eq ( Continuous.star continuous_id' ) continuous_id';
    · exact isClosed_le continuous_const ( continuous_id'.comp ( show Continuous fun rho : H →L[ℂ] H => fun x : H => rho.reApplyInnerSelf x from by continuity ) );
  convert h_pos_closed.inter ( isClosed_eq ( show Continuous fun x : H →L[ℂ] H => LinearMap.trace ℂ H x from ?_ ) continuous_const ) using 1;
  convert LinearMap.continuous_of_finiteDimensional _;
  rotate_left;
  exact ℂ;
  all_goals try infer_instance;
  refine' { .. };
  exact fun x => LinearMap.trace ℂ H x.toLinearMap;
  all_goals norm_num

/-
Theorem stating that a contraction on a non-empty closed subset of a complete metric space has a unique fixed point.
-/
/-- Abstract Lemma: A contraction on a non-empty closed subset of a complete metric space has a unique fixed point. -/
theorem contraction_on_closed_subset_has_unique_fixed_point_v2
    {X : Type*} [MetricSpace X] [CompleteSpace X]
    {S : Set X}
    (h_closed : IsClosed S)
    (h_nonempty : S.Nonempty)
    (f : X → X)
    (h_maps_to : Set.MapsTo f S S)
    (k : NNReal)
    (hk : k < 1)
    (h_contract : ∀ x y, x ∈ S → y ∈ S → dist (f x) (f y) ≤ k * dist x y) :
    ∃! x, x ∈ S ∧ f x = x := by
      -- By the Banach fixed-point theorem, since S is a complete metric space and f is a contraction on S, there exists a unique fixed point x in S such that f(x) = x.
      obtain ⟨x, hx⟩ : ∃ x : X, x ∈ S ∧ f x = x := by
        have h_fixed_point : ∀ (f : S → S), Continuous f → (∀ x y : S, dist (f x) (f y) ≤ k * dist x y) → ∃ x : S, f x = x := by
          intro f hf h_contract
          have h_fixed_point_seq : CauchySeq (fun n => f^[n] ⟨h_nonempty.some, h_nonempty.choose_spec⟩) := by
            have h_fixed_point_seq : ∀ n, dist (f^[n] ⟨h_nonempty.some, h_nonempty.choose_spec⟩) (f^[n+1] ⟨h_nonempty.some, h_nonempty.choose_spec⟩) ≤ k^n * dist ⟨h_nonempty.some, h_nonempty.choose_spec⟩ (f ⟨h_nonempty.some, h_nonempty.choose_spec⟩) := by
              intro n; induction' n with n ih <;> simp_all +decide [ pow_succ', mul_assoc, Function.iterate_succ_apply' ] ;
              exact le_trans ( h_contract _ _ _ _ ) ( mul_le_mul_of_nonneg_left ih ( by positivity ) );
            fapply cauchySeq_of_le_geometric;
            exacts [ ↑k, Dist.dist ⟨ h_nonempty.some, h_nonempty.choose_spec ⟩ ( f ⟨ h_nonempty.some, h_nonempty.choose_spec ⟩ ), hk, fun n => by simpa only [ mul_comm ] using h_fixed_point_seq n ];
          obtain ⟨ x, hx ⟩ := cauchySeq_tendsto_of_complete h_fixed_point_seq;
          exact ⟨ x, tendsto_nhds_unique ( by erw [ ← Filter.tendsto_add_atTop_iff_nat 1 ] ; simpa only [ Function.iterate_succ_apply' ] using hf.continuousAt.tendsto.comp hx ) hx ⟩;
        contrapose! h_fixed_point;
        refine' ⟨ fun x => ⟨ f x, h_maps_to x.2 ⟩, _, _, _ ⟩ <;> simp_all +decide [ Metric.continuous_iff ];
        · exact fun x hx ε εpos => ⟨ ε, εpos, fun y hy hyx => lt_of_le_of_lt ( h_contract _ _ hy hx ) ( by nlinarith [ show ( k : ℝ ) < 1 from hk, show ( 0 : ℝ ) ≤ k from mod_cast k.2, dist_comm y x, show ( Dist.dist y x : ℝ ) < ε from hyx ] ) ⟩;
        · exact fun x hx y hy => h_contract x y hx hy;
      refine' ⟨ x, hx, fun y hy => _ ⟩;
      have := h_contract y x hy.1 hx.1;
      contrapose! this; aesop

/-
Theorem stating that the set of quantum states is non-empty.
-/
/-- The set of quantum states is non-empty. -/
theorem states_nonempty_v2 {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] [Nontrivial H] : {rho : H →L[ℂ] H | is_state rho}.Nonempty := by
  -- Let's choose the maximally mixed state $\rho = \frac{I}{\operatorname{dim}(H)}$.
  use (1 / (Module.finrank ℂ H) : ℂ) • (ContinuousLinearMap.id ℂ H);
  refine' ⟨ _, _ ⟩;
  · refine' ⟨ _, _ ⟩;
    · simp +decide [ IsSelfAdjoint ];
      simp +decide [ Star.star ];
    · simp +decide [ ContinuousLinearMap.reApplyInnerSelf ];
      simp +decide [ inner_smul_left, inner_self_eq_norm_sq_to_K ];
      exact fun x => mul_nonneg ( inv_nonneg.2 ( Nat.cast_nonneg _ ) ) ( by norm_cast; positivity );
  · simp +decide [ LinearMap.trace_eq_matrix_trace ℂ ( Module.finBasis ℂ H ) ];
    exact inv_mul_cancel₀ ( Nat.cast_ne_zero.mpr ( ne_of_gt ( Module.finrank_pos ) ) )

/-
Definition of a contraction on the set of states.
-/
/-- A map Phi is a contraction on the set of states if there exists epsilon > 0 such that
    ||Phi(rho) - Phi(sigma)||_1 <= (1 - epsilon) ||rho - sigma||_1. -/
def is_contraction_on_states
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (Phi : (H →L[ℂ] H) → (H →L[ℂ] H))
    (epsilon : ℝ) : Prop :=
  0 < epsilon ∧ epsilon < 1 ∧
  ∀ (rho sigma : H →L[ℂ] H),
    is_state rho → is_state sigma →
    ‖Phi rho - Phi sigma‖ ≤ (1 - epsilon) * ‖rho - sigma‖

/-
Definition of a contraction on the set of states (v2).
-/
/-- A map Phi is a contraction on the set of states if there exists epsilon > 0 such that
    ||Phi(rho) - Phi(sigma)||_1 <= (1 - epsilon) ||rho - sigma||_1. -/
def is_contraction_on_states_v2
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (Phi : (H →L[ℂ] H) → (H →L[ℂ] H))
    (epsilon : ℝ) : Prop :=
  0 < epsilon ∧ epsilon < 1 ∧
  ∀ (rho sigma : H →L[ℂ] H),
    is_state rho → is_state sigma →
    ‖Phi rho - Phi sigma‖ ≤ (1 - epsilon) * ‖rho - sigma‖

/-
Definition of the WESH Lyapunov functional M_epsilon.
-/
/-- Definition of the WESH Lyapunov functional M_epsilon.
    M_epsilon[rho] = sum_x ( <T^4(x)> - <T^2(x)>^2 ) + sum_{xy} gamma(x,y) C[rho;x,y] <L_{xy}^2> + epsilon Tr(rho^2)
    where L_{xy} = T^2(x) - T^2(y). -/
noncomputable def lyapunov_functional
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (epsilon : ℝ)
    (rho : H →L[ℂ] H) : ℝ :=
  (∑ x, ((LinearMap.trace ℂ H (T x ^ 4 * rho)).re - (LinearMap.trace ℂ H (T x ^ 2 * rho)).re ^ 2)) +
  (∑ x, ∑ y, gamma x y * C rho x y * (LinearMap.trace ℂ H ((T x ^ 2 - T y ^ 2) ^ 2 * rho)).re) +
  epsilon * (LinearMap.trace ℂ H (rho * rho)).re

/-
Definition of potential_phi.
-/
/-- Definitions of potential_phi, effective_time_field, and alignment_condition.
    Phi(x) = sum_y K(x,y) C[rho;x,y]
    T_eff(x) = Re(Tr(T(x) rho))
    Alignment: T_eff(x) - T_eff(y) = k * (Phi(x) - Phi(y)) -/
noncomputable def potential_phi
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (K : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H)
    (x : ι) : ℝ :=
  ∑ y, K x y * C rho x y

/-
Definition of effective_time_field.
-/
/-- Definition of effective_time_field.
    T_eff(x) = Re(Tr(T(x) rho)) -/
noncomputable def effective_time_field
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (rho : H →L[ℂ] H)
    (x : ι) : ℝ :=
  (LinearMap.trace ℂ H (T x * rho)).re

/-
Definition of alignment_condition.
-/
/-- Alignment: T_eff(x) - T_eff(y) = k * (Phi(x) - Phi(y)) -/
def alignment_condition
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (K : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H)
    (k : ℝ) : Prop :=
  ∀ x y, effective_time_field T rho x - effective_time_field T rho y = k * (potential_phi K C rho x - potential_phi K C rho y)

/-
Definition of A_loc.
-/
/-- Definition of the local part of the variational gradient A_loc.
    A_loc = sum_x (T^4(x) - 2 <T^2(x)> T^2(x)) -/
noncomputable def A_loc
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  ∑ x, (T x ^ 4 - 2 * (LinearMap.trace ℂ H (T x ^ 2 * rho)).re • (T x ^ 2))

/-
Definition of A_bi_1.
-/
/-- Definition of the first bilocal part of the variational gradient A_bi_1.
    A_bi_1 = sum_{xy} gamma(x,y) C[rho;x,y] L_{xy}^2
    where L_{xy} = T^2(x) - T^2(y). -/
noncomputable def A_bi_1
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  ∑ x, ∑ y, (gamma x y * C rho x y) • ((T x ^ 2 - T y ^ 2) ^ 2)

/-
Definition of A_bi_2.
-/
/-- Definition of the second bilocal part of the variational gradient A_bi_2.
    A_bi_2 = sum_{xy} gamma(x,y) <L_{xy}^2> G_{xy}
    where G_{xy} is the gradient of C[rho;x,y] with respect to rho. -/
noncomputable def A_bi_2
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  ∑ x, ∑ y, (gamma x y * (LinearMap.trace ℂ H ((T x ^ 2 - T y ^ 2) ^ 2 * rho)).re) • G x y

/-
Definition of trace_clm.
-/
/-- Definition of the trace as a continuous linear map on the space of continuous linear operators. -/
noncomputable def trace_clm
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] :
    (H →L[ℂ] H) →L[ℂ] ℂ :=
  LinearMap.toContinuousLinearMap
    { toFun := fun A => LinearMap.trace ℂ H (A : H →ₗ[ℂ] H)
      map_add' := fun A B => by simp
      map_smul' := fun c A => by simp }

/-
Definition of mul_left_clm.
-/
/-- Definition of left multiplication by A as a continuous linear map on operators. -/
noncomputable def mul_left_clm
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (A : H →L[ℂ] H) : (H →L[ℂ] H) →L[ℂ] (H →L[ℂ] H) :=
  ContinuousLinearMap.mul ℂ (H →L[ℂ] H) A

/-
Definition of trace_re_map.
-/
/-- Definition of the continuous linear map delta_rho |-> Re(Tr(A * delta_rho)).
    We compose left multiplication by A, the trace map, and the real part map.
    We restrict scalars to Real before composing with the real part map. -/
noncomputable def trace_re_map
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (A : H →L[ℂ] H) : (H →L[ℂ] H) →L[ℝ] ℝ :=
  Complex.reCLM.comp (
    (trace_clm.comp (mul_left_clm A)).restrictScalars ℝ
  )

/-
Definition of is_gradient.
-/
/-- Definition of G being the gradient of C with respect to rho.
    For all x, y, the Frechet derivative of C[rho; x, y] is given by the linear map trace_re_map(G[x, y]). -/
def is_gradient
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H) : Prop :=
  ∀ (rho : H →L[ℂ] H),
    is_state rho →
    ∀ x y, HasFDerivAt (fun r => C r x y) (trace_re_map (G x y)) rho

/-
Definition of A_total.
-/
/-- Definition of the total variational gradient A_total.
    A_total = A_loc + A_bi_1 + A_bi_2 + 2 * epsilon * rho. -/
noncomputable def A_total
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ)
    (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  A_loc T rho + A_bi_1 T gamma C rho + A_bi_2 T gamma G rho + (2 * epsilon) • rho

/-
Definition of lyapunov_functional_loc.
-/
/-- Definition of the local part of the Lyapunov functional and its gradient.
    M_loc[rho] = sum_x (<T^4(x)> - <T^2(x)>^2)
    Gradient is A_loc. -/
noncomputable def lyapunov_functional_loc
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (rho : H →L[ℂ] H) : ℝ :=
  ∑ x, ((LinearMap.trace ℂ H (T x ^ 4 * rho)).re - (LinearMap.trace ℂ H (T x ^ 2 * rho)).re ^ 2)

/-
Definition of lyapunov_functional_bi_1.
-/
/-- Definition of the first bilocal part of the Lyapunov functional and its gradient.
    M_bi[rho] = sum_{xy} gamma(x,y) C[rho;x,y] <L_{xy}^2>
    Gradient is A_bi_1 + A_bi_2. -/
noncomputable def lyapunov_functional_bi_1
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H) : ℝ :=
  ∑ x, ∑ y, gamma x y * C rho x y * (LinearMap.trace ℂ H ((T x ^ 2 - T y ^ 2) ^ 2 * rho)).re

/-
Definition of the Lindblad dissipator.
-/
/-- Definition of the Lindblad dissipator and GKSL generator on states (Schrodinger picture). -/
noncomputable def dissipator
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (L : H →L[ℂ] H) (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  L * rho * (ContinuousLinearMap.adjoint L) -
  (1 / 2 : ℂ) • ((ContinuousLinearMap.adjoint L * L) * rho + rho * (ContinuousLinearMap.adjoint L * L))

/-
Definition of the GKSL generator.
-/
/-- Definition of the GKSL generator on states (Schrodinger picture). -/
noncomputable def gksl_generator
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (H_eff : H →L[ℂ] H)
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  (-Complex.I) • comm_op H_eff rho +
  ∑ i, (c i : ℂ) • dissipator (L i) rho

/-
Theorem stating the gradient of the first bilocal part of the Lyapunov functional.
-/
theorem lyapunov_gradient_bi_1
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (rho : H →L[ℂ] H)
    (h_grad : is_gradient C G)
    (h_state : is_state rho) :
    HasFDerivAt (lyapunov_functional_bi_1 T gamma C) (trace_re_map (A_bi_1 T gamma C rho + A_bi_2 T gamma G rho)) rho := by
      have h_def : ∀ x y, HasFDerivAt (fun r => gamma x y * C r x y * (LinearMap.trace ℂ H ((T x ^ 2 - T y ^ 2) ^ 2 * r)).re) (trace_re_map ((gamma x y) • (C rho x y • ((T x ^ 2 - T y ^ 2) ^ 2) + (LinearMap.trace ℂ H ((T x ^ 2 - T y ^ 2) ^ 2 * rho)).re • (G x y)))) rho := by
        intro x y
        have h_deriv_term : HasFDerivAt (fun r => C r x y * (LinearMap.trace ℂ H ((T x ^ 2 - T y ^ 2) ^ 2 * r)).re) (trace_re_map (C rho x y • ((T x ^ 2 - T y ^ 2) ^ 2) + (LinearMap.trace ℂ H ((T x ^ 2 - T y ^ 2) ^ 2 * rho)).re • (G x y))) rho := by
          have := h_grad rho h_state x y;
          convert this.mul ( hasFDerivAt_iff_isLittleO_nhds_zero.mpr _ ) using 1;
          rotate_left;
          exact trace_re_map ( ( T x ^ 2 - T y ^ 2 ) ^ 2 );
          · simp +decide [ mul_add, add_mul, pow_two ];
            exact?;
          · ext; simp +decide [ trace_re_map ] ; ring;
            simp +decide [ mul_left_clm, trace_clm ];
        convert h_deriv_term.const_smul ( gamma x y ) using 1 ; ext ; simp +decide [ mul_assoc ];
        unfold trace_re_map; ext; simp +decide [ mul_assoc ] ;
        simp +decide [ mul_left_clm, trace_clm ];
        ring;
      rw [ show lyapunov_functional_bi_1 T gamma C = fun rho => ∑ x, ∑ y, gamma x y * C rho x y * ( LinearMap.trace ℂ H ( ( T x ^ 2 - T y ^ 2 ) ^ 2 * rho ) |> Complex.re ) by ext; rfl ];
      convert HasFDerivAt.sum fun x _ => HasFDerivAt.sum fun y _ => h_def x y using 1;
      any_goals exact Finset.univ;
      any_goals exact fun _ => Finset.univ;
      · bound;
      · unfold A_bi_1 A_bi_2;
        unfold trace_re_map;
        ext; simp +decide [ mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_add_distrib ] ;
        simp +decide [ mul_left_clm, Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, mul_assoc, mul_comm, mul_left_comm ]

/-
Lemma 2.4 (Part 1): If Phi is a contraction on states, it has a unique fixed point.
-/
/-- Lemma 2.4 (Part 1): If Phi is a contraction on states, it has a unique fixed point.
    Note: We assume the set of states is complete (which it is in finite dimensions). -/
theorem lemma_2_4_unique_stationary_state_v2
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] [Nontrivial H]
    (Phi : (H →L[ℂ] H) → (H →L[ℂ] H))
    (epsilon : ℝ)
    (h_contract : is_contraction_on_states_v2 Phi epsilon)
    (h_maps_to : ∀ rho, is_state rho → is_state (Phi rho)) :
    ∃! rho_inf, is_state rho_inf ∧ Phi rho_inf = rho_inf := by
      -- Let S be the set of quantum states.
      set S : Set (H →L[ℂ] H) := {rho | is_state rho};
      have hS_closed : IsClosed S := by
        exact isClosed_set_of_states
      have hS_nonempty : S.Nonempty := by
        exact states_nonempty_v2
      have h_contraction : ∃ k : NNReal, k < 1 ∧ ∀ x y, x ∈ S → y ∈ S → dist (Phi x) (Phi y) ≤ k * dist x y := by
        obtain ⟨k, hk⟩ := h_contract;
        refine' ⟨ ⟨ 1 - epsilon, _ ⟩, _, _ ⟩;
        exacts [ sub_nonneg.2 hk.1.le, by exact Subtype.mk_lt_mk.2 ( sub_lt_self _ k ), fun x y hx hy => by simpa only [ dist_eq_norm ] using hk.2 x y hx hy ];
      obtain ⟨ k, hk₁, hk₂ ⟩ := h_contraction;
      have := contraction_on_closed_subset_has_unique_fixed_point_v2 hS_closed hS_nonempty Phi h_maps_to k hk₁ hk₂;
      exact this

/-
Definition of lyapunov_functional_reg.
-/
/-- Definition of the regularization part of the Lyapunov functional.
    M_reg[rho] = epsilon * Tr(rho^2) -/
noncomputable def lyapunov_functional_reg
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (epsilon : ℝ)
    (rho : H →L[ℂ] H) : ℝ :=
  epsilon * (LinearMap.trace ℂ H (rho * rho)).re

/-
Definition of hidden_sector_terms.
-/
/-- Definition of the hidden sector terms in the variational gradient.
    These are the terms that depend explicitly on the time field T (A_loc and A_bi_1). -/
noncomputable def hidden_sector_terms
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  A_loc T rho + A_bi_1 T gamma C rho

/-
Proposition that the hidden sector terms vanish.
-/
/-- Proposition that the hidden sector terms vanish. -/
def hidden_sector_vanishes
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H) : Prop :=
  hidden_sector_terms T gamma C rho = 0

/-
Proposition that the alignment condition holds for some k.
-/
/-- Proposition that the alignment condition holds for some k. -/
def alignment_holds
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H) : Prop :=
  ∃ k : ℝ, alignment_condition T gamma C rho k

/-
Definition of is_stationary_point.
-/
/-- Definition of a stationary point for the Lyapunov functional.
    The gradient A_total must be proportional to the identity operator (Lagrange multiplier for the trace constraint). -/
def is_stationary_point
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ)
    (rho : H →L[ℂ] H) : Prop :=
  ∃ lambda : ℝ, A_total T gamma C G epsilon rho = (lambda : ℂ) • 1

/-
Definition of the WESH generator.
-/
/-- Definition of the WESH generator. -/
noncomputable def wesh_generator
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (H_eff : H →L[ℂ] H)
    (T : ι → H →L[ℂ] H)
    (nu : ℝ)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H) : H →L[ℂ] H :=
  (-Complex.I) • comm_op H_eff rho +
  (nu : ℂ) • (∑ i, dissipator (T i ^ 2) rho) +
  ∑ i, ∑ j, (gamma i j * C rho i j : ℂ) • dissipator (T i ^ 2 - T j ^ 2) rho

/-
Definition of satisfying Einstein's field equations.
-/
/-- Definition of satisfying Einstein's field equations in this context.
    This corresponds to the condition that the geometric part of the variational gradient (plus regularization) is stationary. -/
def satisfies_einstein_equations
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ)
    (rho : H →L[ℂ] H) : Prop :=
  ∃ lambda : ℝ, A_bi_2 T gamma G rho + (2 * epsilon) • rho = (lambda : ℂ) • 1

/-
Proposition D.2: The alignment condition implies that the effective action variation yields Einstein's field equations when the hidden sector cancels.
-/
/-- Proposition D.2: The alignment condition implies that the effective action variation yields Einstein's field equations when the hidden sector cancels. -/
theorem prop_D_2_einstein_equations
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ)
    (rho : H →L[ℂ] H)
    (h_stat : is_stationary_point T gamma C G epsilon rho)
    (h_cancel : hidden_sector_terms T gamma C rho = 0) :
    satisfies_einstein_equations T gamma G epsilon rho := by
      obtain ⟨lambda, hlambda⟩ := h_stat
      have h_einstein : A_bi_2 T gamma G rho + (2 * epsilon) • rho = lambda • 1 := by
        unfold A_total hidden_sector_terms at * ; aesop;
      exact ⟨lambda, by simpa [ Algebra.smul_def ] using h_einstein⟩

/-
Checking if hidden_sector_vanishes exists.
-/
#check hidden_sector_vanishes

/-
Checking visibility of identifiers.
-/
#check is_stationary_point
#check alignment_holds
#check hidden_sector_vanishes

/-
Structure capturing the unproven axioms of Appendix D.
-/
/-- Structure capturing the unproven axioms of Appendix D:
    1. Stationarity implies Alignment (Theorem D.1).
    2. Stationarity and Alignment imply Hidden Sector Cancellation (Lemma D.3). -/
structure AppendixD_Axioms
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ) : Prop where
  (thm_D_1 : ∀ rho, is_stationary_point T gamma C G epsilon rho → alignment_holds T gamma C rho)
  (lemma_D_3 : ∀ rho, is_stationary_point T gamma C G epsilon rho → alignment_holds T gamma C rho → hidden_sector_vanishes T gamma C rho)

/-
Theorem 5.1: The WESH flow admits a unique stationary state which satisfies the alignment condition.
-/
/-- Theorem 5.1: The WESH flow admits a unique stationary state which satisfies the alignment condition.
    We assume the flow is a contraction (from mixing/primitivity) and the equivalence between flow fixed points, generator zeros, and variational stationary points. -/
theorem theorem_5_1_fixed_point
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] [Nontrivial H]
    (H_eff : H →L[ℂ] H)
    (T : ι → H →L[ℂ] H)
    (nu : ℝ)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ)
    (axioms : AppendixD_Axioms T gamma C G epsilon)
    (Phi : (H →L[ℂ] H) → (H →L[ℂ] H))
    (eps_contract : ℝ)
    (h_contract : is_contraction_on_states Phi eps_contract)
    (h_maps_to : ∀ rho, is_state rho → is_state (Phi rho))
    (h_equiv_flow : ∀ rho, is_state rho → (Phi rho = rho ↔ wesh_generator H_eff T nu gamma C rho = 0))
    (h_equiv_stat : ∀ rho, is_state rho → (wesh_generator H_eff T nu gamma C rho = 0 ↔ is_stationary_point T gamma C G epsilon rho))
    : ∃! rho_inf, is_state rho_inf ∧ wesh_generator H_eff T nu gamma C rho_inf = 0 ∧ alignment_holds T gamma C rho_inf := by
      obtain ⟨rho_inf, hr_inf⟩ : ∃! rho_inf, is_state rho_inf ∧ Phi rho_inf = rho_inf := by
        apply_rules [ lemma_2_4_unique_stationary_state_v2 ];
      use rho_inf;
      exact ⟨ ⟨ hr_inf.1.1, h_equiv_flow rho_inf hr_inf.1.1 |>.1 hr_inf.1.2, axioms.thm_D_1 rho_inf ( h_equiv_stat rho_inf hr_inf.1.1 |>.1 ( h_equiv_flow rho_inf hr_inf.1.1 |>.1 hr_inf.1.2 ) ) ⟩, fun y hy => hr_inf.2 y ⟨ hy.1, h_equiv_flow y hy.1 |>.2 hy.2.1 ⟩ ⟩

/-
Theorem 5.4: The unique stationary state of the WESH flow satisfies the Einstein equations.
-/
/-- Theorem 5.4: The unique stationary state of the WESH flow satisfies the Einstein equations. -/
theorem theorem_5_4_einstein_emergence
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] [Nontrivial H]
    (H_eff : H →L[ℂ] H)
    (T : ι → H →L[ℂ] H)
    (nu : ℝ)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ)
    (axioms : AppendixD_Axioms T gamma C G epsilon)
    (Phi : (H →L[ℂ] H) → (H →L[ℂ] H))
    (eps_contract : ℝ)
    (h_contract : is_contraction_on_states Phi eps_contract)
    (h_maps_to : ∀ rho, is_state rho → is_state (Phi rho))
    (h_equiv_flow : ∀ rho, is_state rho → (Phi rho = rho ↔ wesh_generator H_eff T nu gamma C rho = 0))
    (h_equiv_stat : ∀ rho, is_state rho → (wesh_generator H_eff T nu gamma C rho = 0 ↔ is_stationary_point T gamma C G epsilon rho))
    (h_nu : 0 < nu)
    (h_gamma : ∀ i j, 0 ≤ gamma i j)
    (h_C_pos : ∀ rho i j, is_state rho → 0 ≤ C rho i j)
    : ∃! rho_inf, is_state rho_inf ∧ wesh_generator H_eff T nu gamma C rho_inf = 0 ∧ satisfies_einstein_equations T gamma G epsilon rho_inf := by
      have h_unique_exists : ∃! rho_inf, is_state rho_inf ∧ wesh_generator H_eff T nu gamma C rho_inf = 0 := by
        have := theorem_5_1_fixed_point H_eff T nu gamma C G epsilon axioms Phi eps_contract h_contract h_maps_to h_equiv_flow h_equiv_stat;
        exact ⟨ this.exists.choose, ⟨ this.exists.choose_spec.1, this.exists.choose_spec.2.1 ⟩, fun rho hr => this.unique ⟨ hr.1, hr.2, axioms.thm_D_1 _ ( h_equiv_stat _ hr.1 |>.1 hr.2 ) ⟩ this.exists.choose_spec ⟩;
      cases' h_unique_exists with rho_inf hrho_inf;
      refine' ⟨ rho_inf, _, _ ⟩;
      · have := axioms.lemma_D_3 rho_inf ( h_equiv_stat rho_inf hrho_inf.1.1 |>.1 hrho_inf.1.2 );
        have := axioms.thm_D_1 rho_inf ( h_equiv_stat rho_inf hrho_inf.1.1 |>.1 hrho_inf.1.2 );
        exact ⟨ hrho_inf.1.1, hrho_inf.1.2, prop_D_2_einstein_equations T gamma C G epsilon rho_inf ( h_equiv_stat rho_inf hrho_inf.1.1 |>.1 hrho_inf.1.2 ) ( by solve_by_elim ) ⟩;
      · exact fun y hy => hrho_inf.2 y ⟨ hy.1, hy.2.1 ⟩

/-
Structure encapsulating the unformalized concepts of actions, diffeomorphism invariance, and Lovelock's theorem.
-/
/-- Structure encapsulating the unformalized concepts of actions, diffeomorphism invariance, and Lovelock's theorem. -/
structure ActionTheory where
  (Action : Type)
  (is_local_diffeomorphism_invariant : Action → Prop)
  (has_second_order_equations : Action → Prop)
  (is_compatible_with_wesh_markov : Action → Prop)
  (is_einstein_hilbert : Action → Prop)
  (lovelock_theorem : ∀ S : Action, is_local_diffeomorphism_invariant S → has_second_order_equations S → is_einstein_hilbert S)
  (ghost_exclusion : ∀ S : Action, is_compatible_with_wesh_markov S → has_second_order_equations S)

/-
Theorem 5.5: In the limit where coupling constants vanish (G -> 0), the WESH generator reduces to the standard Hamiltonian commutator (Von Neumann equation).
-/
/-- Theorem 5.5: In the limit where coupling constants vanish (G -> 0), the WESH generator reduces to the standard Hamiltonian commutator (Von Neumann equation). -/
theorem theorem_5_5_consistency_limit
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (H_eff : H →L[ℂ] H)
    (T : ι → H →L[ℂ] H)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (rho : H →L[ℂ] H) :
    wesh_generator H_eff T 0 (fun _ _ => 0) C rho = (-Complex.I) • comm_op H_eff rho := by
      unfold wesh_generator;
      aesop

/-
Checking existence of AppendixD_Axioms and theorem_5_1_fixed_point.
-/
#check AppendixD_Axioms
#check theorem_5_1_fixed_point

/-
Lemma 2.4 (Part 1): If Phi is a contraction on states, it has a unique fixed point.
-/
/-- Lemma 2.4 (Part 1): If Phi is a contraction on states, it has a unique fixed point.
    Note: We assume the set of states is complete (which it is in finite dimensions). -/
theorem lemma_2_4_unique_stationary_state
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H] [Nontrivial H]
    (Phi : (H →L[ℂ] H) → (H →L[ℂ] H))
    (epsilon : ℝ)
    (h_contract : is_contraction_on_states Phi epsilon)
    (h_maps_to : ∀ rho, is_state rho → is_state (Phi rho)) :
    ∃! rho_inf, is_state rho_inf ∧ Phi rho_inf = rho_inf := by
      -- Let S be the set of quantum states.
      set S : Set (H →L[ℂ] H) := {rho | is_state rho};
      have hS_closed : IsClosed S := by
        exact isClosed_set_of_states
      have hS_nonempty : S.Nonempty := by
        exact states_nonempty_v2
      have h_contraction : ∃ k : NNReal, k < 1 ∧ ∀ x y, x ∈ S → y ∈ S → dist (Phi x) (Phi y) ≤ k * dist x y := by
        obtain ⟨k, hk⟩ := h_contract;
        refine' ⟨ ⟨ 1 - epsilon, _ ⟩, _, _ ⟩;
        exacts [ sub_nonneg.2 hk.1.le, by exact Subtype.mk_lt_mk.2 ( sub_lt_self _ k ), fun x y hx hy => by simpa only [ dist_eq_norm ] using hk.2 x y hx hy ];
      obtain ⟨ k, hk₁, hk₂ ⟩ := h_contraction;
      have := contraction_on_closed_subset_has_unique_fixed_point_v2 hS_closed hS_nonempty Phi h_maps_to k hk₁ hk₂;
      exact this

/-
Main result of Appendix D: Under the axioms of Variational Alignment and Hidden Sector Cancellation, a stationary point satisfies Einstein's equations.
-/
/-- Main result of Appendix D: Under the axioms of Variational Alignment and Hidden Sector Cancellation, a stationary point satisfies Einstein's equations. -/
theorem appendix_D_main_result
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (T : ι → H →L[ℂ] H)
    (gamma : ι → ι → ℝ)
    (C : (H →L[ℂ] H) → ι → ι → ℝ)
    (G : ι → ι → H →L[ℂ] H)
    (epsilon : ℝ)
    (axioms : AppendixD_Axioms T gamma C G epsilon)
    (rho : H →L[ℂ] H)
    (h_stat : is_stationary_point T gamma C G epsilon rho) :
    satisfies_einstein_equations T gamma G epsilon rho := by
      exact prop_D_2_einstein_equations T gamma C G epsilon rho h_stat ( axioms.2 rho h_stat ( axioms.1 rho h_stat ) )

/-
Lemma 5.3: In D=4, among local diffeomorphism-invariant actions, only the Einstein-Hilbert action is compatible with the CP/Markov WESH constraints.
-/
/-- Lemma 5.3: In D=4, among local diffeomorphism-invariant actions, only the Einstein-Hilbert action is compatible with the CP/Markov WESH constraints. -/
theorem lemma_5_3_IR_filter
    (T : ActionTheory)
    (S : T.Action)
    (h_local : T.is_local_diffeomorphism_invariant S)
    (h_markov : T.is_compatible_with_wesh_markov S) :
    T.is_einstein_hilbert S := by
      have := T.ghost_exclusion S;
      have := T.lovelock_theorem S; aesop;

/-
Lemma 2.2 (Part 2): Gamma is non-negative if rho is positive and rates are non-negative.
-/
/-- Lemma 2.2 (Part 2): Gamma is non-negative if rho is positive and rates are non-negative. -/
theorem gamma_functional_nonneg
    {ι : Type*} [Fintype ι]
    {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H] [FiniteDimensional ℂ H]
    (L : ι → H →L[ℂ] H)
    (c : ι → ℝ)
    (rho : H →L[ℂ] H)
    (h_rho : ContinuousLinearMap.IsPositive rho)
    (hc : ∀ i, 0 ≤ c i) :
    0 ≤ gamma_functional L c rho := by
      apply Finset.sum_nonneg;
      exact fun i _ => mul_nonneg ( hc i ) ( gamma_contribution_nonneg ( L i ) rho h_rho )

/-
Final check of main theorems.
-/
#check theorem_5_1_fixed_point
#check theorem_5_4_einstein_emergence
#check lemma_5_3_IR_filter
#check theorem_5_5_consistency_limit